{"ast":null,"code":"import { autoUpdate, offset, flip, shift, limitShift, arrow, size, hide, computePosition } from '@floating-ui/dom';\nimport { raf, isHTMLElement, getWindow, getComputedStyle } from '@zag-js/dom-query';\nimport { noop, isNull, compact } from '@zag-js/utils';\n\n// src/get-placement.ts\nfunction createDOMRect(x = 0, y = 0, width = 0, height = 0) {\n  if (typeof DOMRect === \"function\") {\n    return new DOMRect(x, y, width, height);\n  }\n  const rect = {\n    x,\n    y,\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x\n  };\n  return {\n    ...rect,\n    toJSON: () => rect\n  };\n}\nfunction getDOMRect(anchorRect) {\n  if (!anchorRect) return createDOMRect();\n  const {\n    x,\n    y,\n    width,\n    height\n  } = anchorRect;\n  return createDOMRect(x, y, width, height);\n}\nfunction getAnchorElement(anchorElement, getAnchorRect) {\n  return {\n    contextElement: isHTMLElement(anchorElement) ? anchorElement : void 0,\n    getBoundingClientRect: () => {\n      const anchor = anchorElement;\n      const anchorRect = getAnchorRect?.(anchor);\n      if (anchorRect || !anchor) {\n        return getDOMRect(anchorRect);\n      }\n      return anchor.getBoundingClientRect();\n    }\n  };\n}\n\n// src/middleware.ts\nvar toVar = value => ({\n  variable: value,\n  reference: `var(${value})`\n});\nvar cssVars = {\n  arrowSize: toVar(\"--arrow-size\"),\n  arrowSizeHalf: toVar(\"--arrow-size-half\"),\n  arrowBg: toVar(\"--arrow-background\"),\n  transformOrigin: toVar(\"--transform-origin\"),\n  arrowOffset: toVar(\"--arrow-offset\")\n};\nvar getSideAxis = side => side === \"top\" || side === \"bottom\" ? \"y\" : \"x\";\nfunction createTransformOriginMiddleware(opts, arrowEl) {\n  return {\n    name: \"transformOrigin\",\n    fn(state) {\n      const {\n        elements,\n        middlewareData,\n        placement,\n        rects,\n        y\n      } = state;\n      const side = placement.split(\"-\")[0];\n      const axis = getSideAxis(side);\n      const arrowX = middlewareData.arrow?.x || 0;\n      const arrowY = middlewareData.arrow?.y || 0;\n      const arrowWidth = arrowEl?.clientWidth || 0;\n      const arrowHeight = arrowEl?.clientHeight || 0;\n      const transformX = arrowX + arrowWidth / 2;\n      const transformY = arrowY + arrowHeight / 2;\n      const shiftY = Math.abs(middlewareData.shift?.y || 0);\n      const halfAnchorHeight = rects.reference.height / 2;\n      const arrowOffset = arrowHeight / 2;\n      const gutter = opts.offset?.mainAxis ?? opts.gutter;\n      const sideOffsetValue = typeof gutter === \"number\" ? gutter + arrowOffset : gutter ?? arrowOffset;\n      const isOverlappingAnchor = shiftY > sideOffsetValue;\n      const adjacentTransformOrigin = {\n        top: `${transformX}px calc(100% + ${sideOffsetValue}px)`,\n        bottom: `${transformX}px ${-sideOffsetValue}px`,\n        left: `calc(100% + ${sideOffsetValue}px) ${transformY}px`,\n        right: `${-sideOffsetValue}px ${transformY}px`\n      }[side];\n      const overlapTransformOrigin = `${transformX}px ${rects.reference.y + halfAnchorHeight - y}px`;\n      const useOverlap = Boolean(opts.overlap) && axis === \"y\" && isOverlappingAnchor;\n      elements.floating.style.setProperty(cssVars.transformOrigin.variable, useOverlap ? overlapTransformOrigin : adjacentTransformOrigin);\n      return {\n        data: {\n          transformOrigin: useOverlap ? overlapTransformOrigin : adjacentTransformOrigin\n        }\n      };\n    }\n  };\n}\nvar rectMiddleware = {\n  name: \"rects\",\n  fn({\n    rects\n  }) {\n    return {\n      data: rects\n    };\n  }\n};\nvar shiftArrowMiddleware = arrowEl => {\n  if (!arrowEl) return;\n  return {\n    name: \"shiftArrow\",\n    fn({\n      placement,\n      middlewareData\n    }) {\n      if (!middlewareData.arrow) return {};\n      const {\n        x,\n        y\n      } = middlewareData.arrow;\n      const dir = placement.split(\"-\")[0];\n      Object.assign(arrowEl.style, {\n        left: x != null ? `${x}px` : \"\",\n        top: y != null ? `${y}px` : \"\",\n        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`\n      });\n      return {};\n    }\n  };\n};\n\n// src/placement.ts\nfunction isValidPlacement(v) {\n  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(v);\n}\nfunction getPlacementDetails(placement) {\n  const [side, align] = placement.split(\"-\");\n  return {\n    side,\n    align,\n    hasAlign: align != null\n  };\n}\nfunction getPlacementSide(placement) {\n  return placement.split(\"-\")[0];\n}\n\n// src/get-placement.ts\nvar defaultOptions = {\n  strategy: \"absolute\",\n  placement: \"bottom\",\n  listeners: true,\n  gutter: 8,\n  flip: true,\n  slide: true,\n  overlap: false,\n  sameWidth: false,\n  fitViewport: false,\n  overflowPadding: 8,\n  arrowPadding: 4\n};\nfunction roundByDpr(win, value) {\n  const dpr = win.devicePixelRatio || 1;\n  return Math.round(value * dpr) / dpr;\n}\nfunction resolveBoundaryOption(boundary) {\n  if (typeof boundary === \"function\") return boundary();\n  if (boundary === \"clipping-ancestors\") return \"clippingAncestors\";\n  return boundary;\n}\nfunction getArrowMiddleware(arrowElement, doc, opts) {\n  const element = arrowElement || doc.createElement(\"div\");\n  return arrow({\n    element,\n    padding: opts.arrowPadding\n  });\n}\nfunction getOffsetMiddleware(arrowElement, opts) {\n  if (isNull(opts.offset ?? opts.gutter)) return;\n  return offset(({\n    placement\n  }) => {\n    const arrowOffset = (arrowElement?.clientHeight || 0) / 2;\n    const gutter = opts.offset?.mainAxis ?? opts.gutter;\n    const mainAxis = typeof gutter === \"number\" ? gutter + arrowOffset : gutter ?? arrowOffset;\n    const {\n      hasAlign\n    } = getPlacementDetails(placement);\n    const shift2 = !hasAlign ? opts.shift : void 0;\n    const crossAxis = opts.offset?.crossAxis ?? shift2;\n    return compact({\n      crossAxis,\n      mainAxis,\n      alignmentAxis: opts.shift\n    });\n  });\n}\nfunction getFlipMiddleware(opts) {\n  if (!opts.flip) return;\n  const boundary = resolveBoundaryOption(opts.boundary);\n  return flip({\n    ...(boundary ? {\n      boundary\n    } : void 0),\n    padding: opts.overflowPadding,\n    fallbackPlacements: opts.flip === true ? void 0 : opts.flip\n  });\n}\nfunction getShiftMiddleware(opts) {\n  if (!opts.slide && !opts.overlap) return;\n  const boundary = resolveBoundaryOption(opts.boundary);\n  return shift({\n    ...(boundary ? {\n      boundary\n    } : void 0),\n    mainAxis: opts.slide,\n    crossAxis: opts.overlap,\n    padding: opts.overflowPadding,\n    limiter: limitShift()\n  });\n}\nfunction getSizeMiddleware(opts) {\n  return size({\n    padding: opts.overflowPadding,\n    apply({\n      elements,\n      rects,\n      availableHeight,\n      availableWidth\n    }) {\n      const floating = elements.floating;\n      const referenceWidth = Math.round(rects.reference.width);\n      const referenceHeight = Math.round(rects.reference.height);\n      availableWidth = Math.floor(availableWidth);\n      availableHeight = Math.floor(availableHeight);\n      floating.style.setProperty(\"--reference-width\", `${referenceWidth}px`);\n      floating.style.setProperty(\"--reference-height\", `${referenceHeight}px`);\n      floating.style.setProperty(\"--available-width\", `${availableWidth}px`);\n      floating.style.setProperty(\"--available-height\", `${availableHeight}px`);\n    }\n  });\n}\nfunction hideWhenDetachedMiddleware(opts) {\n  if (!opts.hideWhenDetached) return;\n  return hide({\n    strategy: \"referenceHidden\",\n    boundary: resolveBoundaryOption(opts.boundary) ?? \"clippingAncestors\"\n  });\n}\nfunction getAutoUpdateOptions(opts) {\n  if (!opts) return {};\n  if (opts === true) {\n    return {\n      ancestorResize: true,\n      ancestorScroll: true,\n      elementResize: true,\n      layoutShift: true\n    };\n  }\n  return opts;\n}\nfunction getPlacementImpl(referenceOrVirtual, floating, opts = {}) {\n  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);\n  if (!floating || !reference) return;\n  const options = Object.assign({}, defaultOptions, opts);\n  const arrowEl = floating.querySelector(\"[data-part=arrow]\");\n  const middleware = [getOffsetMiddleware(arrowEl, options), getFlipMiddleware(options), getShiftMiddleware(options), getArrowMiddleware(arrowEl, floating.ownerDocument, options), shiftArrowMiddleware(arrowEl), createTransformOriginMiddleware({\n    gutter: options.gutter,\n    offset: options.offset,\n    overlap: options.overlap\n  }, arrowEl), getSizeMiddleware(options), hideWhenDetachedMiddleware(options), rectMiddleware];\n  const {\n    placement,\n    strategy,\n    onComplete,\n    onPositioned\n  } = options;\n  const updatePosition = async () => {\n    if (!reference || !floating) return;\n    const pos = await computePosition(reference, floating, {\n      placement,\n      middleware,\n      strategy\n    });\n    onComplete?.(pos);\n    onPositioned?.({\n      placed: true\n    });\n    const win = getWindow(floating);\n    const x = roundByDpr(win, pos.x);\n    const y = roundByDpr(win, pos.y);\n    floating.style.setProperty(\"--x\", `${x}px`);\n    floating.style.setProperty(\"--y\", `${y}px`);\n    if (options.hideWhenDetached) {\n      const isHidden = pos.middlewareData.hide?.referenceHidden;\n      if (isHidden) {\n        floating.style.setProperty(\"visibility\", \"hidden\");\n        floating.style.setProperty(\"pointer-events\", \"none\");\n      } else {\n        floating.style.removeProperty(\"visibility\");\n        floating.style.removeProperty(\"pointer-events\");\n      }\n    }\n    const contentEl = floating.firstElementChild;\n    if (contentEl) {\n      const styles = getComputedStyle(contentEl);\n      floating.style.setProperty(\"--z-index\", styles.zIndex);\n    }\n  };\n  const update = async () => {\n    if (opts.updatePosition) {\n      await opts.updatePosition({\n        updatePosition,\n        floatingElement: floating\n      });\n      onPositioned?.({\n        placed: true\n      });\n    } else {\n      await updatePosition();\n    }\n  };\n  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);\n  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop;\n  update();\n  return () => {\n    cancelAutoUpdate?.();\n    onPositioned?.({\n      placed: false\n    });\n  };\n}\nfunction getPlacement(referenceOrFn, floatingOrFn, opts = {}) {\n  const {\n    defer,\n    ...options\n  } = opts;\n  const func = defer ? raf : v => v();\n  const cleanups = [];\n  cleanups.push(func(() => {\n    const reference = typeof referenceOrFn === \"function\" ? referenceOrFn() : referenceOrFn;\n    const floating = typeof floatingOrFn === \"function\" ? floatingOrFn() : floatingOrFn;\n    cleanups.push(getPlacementImpl(reference, floating, options));\n  }));\n  return () => {\n    cleanups.forEach(fn => fn?.());\n  };\n}\n\n// src/get-styles.ts\nvar ARROW_FLOATING_STYLE = {\n  bottom: \"rotate(45deg)\",\n  left: \"rotate(135deg)\",\n  top: \"rotate(225deg)\",\n  right: \"rotate(315deg)\"\n};\nfunction getPlacementStyles(options = {}) {\n  const {\n    placement,\n    sameWidth,\n    fitViewport,\n    strategy = \"absolute\"\n  } = options;\n  return {\n    arrow: {\n      position: \"absolute\",\n      width: cssVars.arrowSize.reference,\n      height: cssVars.arrowSize.reference,\n      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,\n      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`\n    },\n    arrowTip: {\n      // @ts-expect-error - Fix this\n      transform: placement ? ARROW_FLOATING_STYLE[placement.split(\"-\")[0]] : void 0,\n      background: cssVars.arrowBg.reference,\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      position: \"absolute\",\n      zIndex: \"inherit\"\n    },\n    floating: {\n      position: strategy,\n      isolation: \"isolate\",\n      minWidth: sameWidth ? void 0 : \"max-content\",\n      width: sameWidth ? \"var(--reference-width)\" : void 0,\n      maxWidth: fitViewport ? \"var(--available-width)\" : void 0,\n      maxHeight: fitViewport ? \"var(--available-height)\" : void 0,\n      pointerEvents: !placement ? \"none\" : void 0,\n      top: \"0px\",\n      left: \"0px\",\n      // move off-screen if placement is not defined\n      transform: placement ? \"translate3d(var(--x), var(--y), 0)\" : \"translate3d(0, -100vh, 0)\",\n      zIndex: \"var(--z-index)\"\n    }\n  };\n}\nexport { getPlacement, getPlacementSide, getPlacementStyles, isValidPlacement };","map":{"version":3,"names":["autoUpdate","offset","flip","shift","limitShift","arrow","size","hide","computePosition","raf","isHTMLElement","getWindow","getComputedStyle","noop","isNull","compact","createDOMRect","x","y","width","height","DOMRect","rect","top","right","bottom","left","toJSON","getDOMRect","anchorRect","getAnchorElement","anchorElement","getAnchorRect","contextElement","getBoundingClientRect","anchor","toVar","value","variable","reference","cssVars","arrowSize","arrowSizeHalf","arrowBg","transformOrigin","arrowOffset","getSideAxis","side","createTransformOriginMiddleware","opts","arrowEl","name","fn","state","elements","middlewareData","placement","rects","split","axis","arrowX","arrowY","arrowWidth","clientWidth","arrowHeight","clientHeight","transformX","transformY","shiftY","Math","abs","halfAnchorHeight","gutter","mainAxis","sideOffsetValue","isOverlappingAnchor","adjacentTransformOrigin","overlapTransformOrigin","useOverlap","Boolean","overlap","floating","style","setProperty","data","rectMiddleware","shiftArrowMiddleware","dir","Object","assign","isValidPlacement","v","test","getPlacementDetails","align","hasAlign","getPlacementSide","defaultOptions","strategy","listeners","slide","sameWidth","fitViewport","overflowPadding","arrowPadding","roundByDpr","win","dpr","devicePixelRatio","round","resolveBoundaryOption","boundary","getArrowMiddleware","arrowElement","doc","element","createElement","padding","getOffsetMiddleware","shift2","crossAxis","alignmentAxis","getFlipMiddleware","fallbackPlacements","getShiftMiddleware","limiter","getSizeMiddleware","apply","availableHeight","availableWidth","referenceWidth","referenceHeight","floor","hideWhenDetachedMiddleware","hideWhenDetached","getAutoUpdateOptions","ancestorResize","ancestorScroll","elementResize","layoutShift","getPlacementImpl","referenceOrVirtual","options","querySelector","middleware","ownerDocument","onComplete","onPositioned","updatePosition","pos","placed","isHidden","referenceHidden","removeProperty","contentEl","firstElementChild","styles","zIndex","update","floatingElement","autoUpdateOptions","cancelAutoUpdate","getPlacement","referenceOrFn","floatingOrFn","defer","func","cleanups","push","forEach","ARROW_FLOATING_STYLE","getPlacementStyles","position","arrowTip","transform","background","isolation","minWidth","maxWidth","maxHeight","pointerEvents"],"sources":["/Users/ameliamagick/personal-finance-tracker/node_modules/@zag-js/popper/dist/index.mjs"],"sourcesContent":["import { autoUpdate, offset, flip, shift, limitShift, arrow, size, hide, computePosition } from '@floating-ui/dom';\nimport { raf, isHTMLElement, getWindow, getComputedStyle } from '@zag-js/dom-query';\nimport { noop, isNull, compact } from '@zag-js/utils';\n\n// src/get-placement.ts\nfunction createDOMRect(x = 0, y = 0, width = 0, height = 0) {\n  if (typeof DOMRect === \"function\") {\n    return new DOMRect(x, y, width, height);\n  }\n  const rect = {\n    x,\n    y,\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x\n  };\n  return { ...rect, toJSON: () => rect };\n}\nfunction getDOMRect(anchorRect) {\n  if (!anchorRect) return createDOMRect();\n  const { x, y, width, height } = anchorRect;\n  return createDOMRect(x, y, width, height);\n}\nfunction getAnchorElement(anchorElement, getAnchorRect) {\n  return {\n    contextElement: isHTMLElement(anchorElement) ? anchorElement : void 0,\n    getBoundingClientRect: () => {\n      const anchor = anchorElement;\n      const anchorRect = getAnchorRect?.(anchor);\n      if (anchorRect || !anchor) {\n        return getDOMRect(anchorRect);\n      }\n      return anchor.getBoundingClientRect();\n    }\n  };\n}\n\n// src/middleware.ts\nvar toVar = (value) => ({ variable: value, reference: `var(${value})` });\nvar cssVars = {\n  arrowSize: toVar(\"--arrow-size\"),\n  arrowSizeHalf: toVar(\"--arrow-size-half\"),\n  arrowBg: toVar(\"--arrow-background\"),\n  transformOrigin: toVar(\"--transform-origin\"),\n  arrowOffset: toVar(\"--arrow-offset\")\n};\nvar getSideAxis = (side) => side === \"top\" || side === \"bottom\" ? \"y\" : \"x\";\nfunction createTransformOriginMiddleware(opts, arrowEl) {\n  return {\n    name: \"transformOrigin\",\n    fn(state) {\n      const { elements, middlewareData, placement, rects, y } = state;\n      const side = placement.split(\"-\")[0];\n      const axis = getSideAxis(side);\n      const arrowX = middlewareData.arrow?.x || 0;\n      const arrowY = middlewareData.arrow?.y || 0;\n      const arrowWidth = arrowEl?.clientWidth || 0;\n      const arrowHeight = arrowEl?.clientHeight || 0;\n      const transformX = arrowX + arrowWidth / 2;\n      const transformY = arrowY + arrowHeight / 2;\n      const shiftY = Math.abs(middlewareData.shift?.y || 0);\n      const halfAnchorHeight = rects.reference.height / 2;\n      const arrowOffset = arrowHeight / 2;\n      const gutter = opts.offset?.mainAxis ?? opts.gutter;\n      const sideOffsetValue = typeof gutter === \"number\" ? gutter + arrowOffset : gutter ?? arrowOffset;\n      const isOverlappingAnchor = shiftY > sideOffsetValue;\n      const adjacentTransformOrigin = {\n        top: `${transformX}px calc(100% + ${sideOffsetValue}px)`,\n        bottom: `${transformX}px ${-sideOffsetValue}px`,\n        left: `calc(100% + ${sideOffsetValue}px) ${transformY}px`,\n        right: `${-sideOffsetValue}px ${transformY}px`\n      }[side];\n      const overlapTransformOrigin = `${transformX}px ${rects.reference.y + halfAnchorHeight - y}px`;\n      const useOverlap = Boolean(opts.overlap) && axis === \"y\" && isOverlappingAnchor;\n      elements.floating.style.setProperty(\n        cssVars.transformOrigin.variable,\n        useOverlap ? overlapTransformOrigin : adjacentTransformOrigin\n      );\n      return {\n        data: {\n          transformOrigin: useOverlap ? overlapTransformOrigin : adjacentTransformOrigin\n        }\n      };\n    }\n  };\n}\nvar rectMiddleware = {\n  name: \"rects\",\n  fn({ rects }) {\n    return {\n      data: rects\n    };\n  }\n};\nvar shiftArrowMiddleware = (arrowEl) => {\n  if (!arrowEl) return;\n  return {\n    name: \"shiftArrow\",\n    fn({ placement, middlewareData }) {\n      if (!middlewareData.arrow) return {};\n      const { x, y } = middlewareData.arrow;\n      const dir = placement.split(\"-\")[0];\n      Object.assign(arrowEl.style, {\n        left: x != null ? `${x}px` : \"\",\n        top: y != null ? `${y}px` : \"\",\n        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`\n      });\n      return {};\n    }\n  };\n};\n\n// src/placement.ts\nfunction isValidPlacement(v) {\n  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(v);\n}\nfunction getPlacementDetails(placement) {\n  const [side, align] = placement.split(\"-\");\n  return { side, align, hasAlign: align != null };\n}\nfunction getPlacementSide(placement) {\n  return placement.split(\"-\")[0];\n}\n\n// src/get-placement.ts\nvar defaultOptions = {\n  strategy: \"absolute\",\n  placement: \"bottom\",\n  listeners: true,\n  gutter: 8,\n  flip: true,\n  slide: true,\n  overlap: false,\n  sameWidth: false,\n  fitViewport: false,\n  overflowPadding: 8,\n  arrowPadding: 4\n};\nfunction roundByDpr(win, value) {\n  const dpr = win.devicePixelRatio || 1;\n  return Math.round(value * dpr) / dpr;\n}\nfunction resolveBoundaryOption(boundary) {\n  if (typeof boundary === \"function\") return boundary();\n  if (boundary === \"clipping-ancestors\") return \"clippingAncestors\";\n  return boundary;\n}\nfunction getArrowMiddleware(arrowElement, doc, opts) {\n  const element = arrowElement || doc.createElement(\"div\");\n  return arrow({ element, padding: opts.arrowPadding });\n}\nfunction getOffsetMiddleware(arrowElement, opts) {\n  if (isNull(opts.offset ?? opts.gutter)) return;\n  return offset(({ placement }) => {\n    const arrowOffset = (arrowElement?.clientHeight || 0) / 2;\n    const gutter = opts.offset?.mainAxis ?? opts.gutter;\n    const mainAxis = typeof gutter === \"number\" ? gutter + arrowOffset : gutter ?? arrowOffset;\n    const { hasAlign } = getPlacementDetails(placement);\n    const shift2 = !hasAlign ? opts.shift : void 0;\n    const crossAxis = opts.offset?.crossAxis ?? shift2;\n    return compact({\n      crossAxis,\n      mainAxis,\n      alignmentAxis: opts.shift\n    });\n  });\n}\nfunction getFlipMiddleware(opts) {\n  if (!opts.flip) return;\n  const boundary = resolveBoundaryOption(opts.boundary);\n  return flip({\n    ...boundary ? { boundary } : void 0,\n    padding: opts.overflowPadding,\n    fallbackPlacements: opts.flip === true ? void 0 : opts.flip\n  });\n}\nfunction getShiftMiddleware(opts) {\n  if (!opts.slide && !opts.overlap) return;\n  const boundary = resolveBoundaryOption(opts.boundary);\n  return shift({\n    ...boundary ? { boundary } : void 0,\n    mainAxis: opts.slide,\n    crossAxis: opts.overlap,\n    padding: opts.overflowPadding,\n    limiter: limitShift()\n  });\n}\nfunction getSizeMiddleware(opts) {\n  return size({\n    padding: opts.overflowPadding,\n    apply({ elements, rects, availableHeight, availableWidth }) {\n      const floating = elements.floating;\n      const referenceWidth = Math.round(rects.reference.width);\n      const referenceHeight = Math.round(rects.reference.height);\n      availableWidth = Math.floor(availableWidth);\n      availableHeight = Math.floor(availableHeight);\n      floating.style.setProperty(\"--reference-width\", `${referenceWidth}px`);\n      floating.style.setProperty(\"--reference-height\", `${referenceHeight}px`);\n      floating.style.setProperty(\"--available-width\", `${availableWidth}px`);\n      floating.style.setProperty(\"--available-height\", `${availableHeight}px`);\n    }\n  });\n}\nfunction hideWhenDetachedMiddleware(opts) {\n  if (!opts.hideWhenDetached) return;\n  return hide({ strategy: \"referenceHidden\", boundary: resolveBoundaryOption(opts.boundary) ?? \"clippingAncestors\" });\n}\nfunction getAutoUpdateOptions(opts) {\n  if (!opts) return {};\n  if (opts === true) {\n    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };\n  }\n  return opts;\n}\nfunction getPlacementImpl(referenceOrVirtual, floating, opts = {}) {\n  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);\n  if (!floating || !reference) return;\n  const options = Object.assign({}, defaultOptions, opts);\n  const arrowEl = floating.querySelector(\"[data-part=arrow]\");\n  const middleware = [\n    getOffsetMiddleware(arrowEl, options),\n    getFlipMiddleware(options),\n    getShiftMiddleware(options),\n    getArrowMiddleware(arrowEl, floating.ownerDocument, options),\n    shiftArrowMiddleware(arrowEl),\n    createTransformOriginMiddleware(\n      { gutter: options.gutter, offset: options.offset, overlap: options.overlap },\n      arrowEl\n    ),\n    getSizeMiddleware(options),\n    hideWhenDetachedMiddleware(options),\n    rectMiddleware\n  ];\n  const { placement, strategy, onComplete, onPositioned } = options;\n  const updatePosition = async () => {\n    if (!reference || !floating) return;\n    const pos = await computePosition(reference, floating, {\n      placement,\n      middleware,\n      strategy\n    });\n    onComplete?.(pos);\n    onPositioned?.({ placed: true });\n    const win = getWindow(floating);\n    const x = roundByDpr(win, pos.x);\n    const y = roundByDpr(win, pos.y);\n    floating.style.setProperty(\"--x\", `${x}px`);\n    floating.style.setProperty(\"--y\", `${y}px`);\n    if (options.hideWhenDetached) {\n      const isHidden = pos.middlewareData.hide?.referenceHidden;\n      if (isHidden) {\n        floating.style.setProperty(\"visibility\", \"hidden\");\n        floating.style.setProperty(\"pointer-events\", \"none\");\n      } else {\n        floating.style.removeProperty(\"visibility\");\n        floating.style.removeProperty(\"pointer-events\");\n      }\n    }\n    const contentEl = floating.firstElementChild;\n    if (contentEl) {\n      const styles = getComputedStyle(contentEl);\n      floating.style.setProperty(\"--z-index\", styles.zIndex);\n    }\n  };\n  const update = async () => {\n    if (opts.updatePosition) {\n      await opts.updatePosition({ updatePosition, floatingElement: floating });\n      onPositioned?.({ placed: true });\n    } else {\n      await updatePosition();\n    }\n  };\n  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);\n  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop;\n  update();\n  return () => {\n    cancelAutoUpdate?.();\n    onPositioned?.({ placed: false });\n  };\n}\nfunction getPlacement(referenceOrFn, floatingOrFn, opts = {}) {\n  const { defer, ...options } = opts;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const reference = typeof referenceOrFn === \"function\" ? referenceOrFn() : referenceOrFn;\n      const floating = typeof floatingOrFn === \"function\" ? floatingOrFn() : floatingOrFn;\n      cleanups.push(getPlacementImpl(reference, floating, options));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n// src/get-styles.ts\nvar ARROW_FLOATING_STYLE = {\n  bottom: \"rotate(45deg)\",\n  left: \"rotate(135deg)\",\n  top: \"rotate(225deg)\",\n  right: \"rotate(315deg)\"\n};\nfunction getPlacementStyles(options = {}) {\n  const { placement, sameWidth, fitViewport, strategy = \"absolute\" } = options;\n  return {\n    arrow: {\n      position: \"absolute\",\n      width: cssVars.arrowSize.reference,\n      height: cssVars.arrowSize.reference,\n      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,\n      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`\n    },\n    arrowTip: {\n      // @ts-expect-error - Fix this\n      transform: placement ? ARROW_FLOATING_STYLE[placement.split(\"-\")[0]] : void 0,\n      background: cssVars.arrowBg.reference,\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      position: \"absolute\",\n      zIndex: \"inherit\"\n    },\n    floating: {\n      position: strategy,\n      isolation: \"isolate\",\n      minWidth: sameWidth ? void 0 : \"max-content\",\n      width: sameWidth ? \"var(--reference-width)\" : void 0,\n      maxWidth: fitViewport ? \"var(--available-width)\" : void 0,\n      maxHeight: fitViewport ? \"var(--available-height)\" : void 0,\n      pointerEvents: !placement ? \"none\" : void 0,\n      top: \"0px\",\n      left: \"0px\",\n      // move off-screen if placement is not defined\n      transform: placement ? \"translate3d(var(--x), var(--y), 0)\" : \"translate3d(0, -100vh, 0)\",\n      zIndex: \"var(--z-index)\"\n    }\n  };\n}\n\nexport { getPlacement, getPlacementSide, getPlacementStyles, isValidPlacement };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}