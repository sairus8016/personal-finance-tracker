{"ast":null,"code":"// src/normalize-span.ts\nvar normalizeSpan = (spans, len) => {\n  const result = [];\n  const append = (start, end, match) => {\n    if (end - start > 0) result.push({\n      start,\n      end,\n      match\n    });\n  };\n  if (spans.length === 0) {\n    append(0, len, false);\n  } else {\n    let lastIndex = 0;\n    for (const chunk of spans) {\n      append(lastIndex, chunk.start, false);\n      append(chunk.start, chunk.end, true);\n      lastIndex = chunk.end;\n    }\n    append(lastIndex, len, false);\n  }\n  return result;\n};\n\n// src/escape-regex.ts\nvar escapeRegex = term => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, char => `\\\\${char}`);\n\n// src/highlight-first.ts\nfunction highlightFirst(props) {\n  const {\n    text,\n    query,\n    ignoreCase,\n    exactMatch\n  } = props;\n  if (exactMatch) {\n    const escapedQuery = escapeRegex(query);\n    const regex = new RegExp(`\\\\b(${escapedQuery})\\\\b`, ignoreCase ? \"i\" : \"\");\n    const match = text.match(regex);\n    if (!match || match.index === void 0) {\n      return [{\n        text,\n        match: false\n      }];\n    }\n    const start2 = match.index;\n    const end2 = start2 + match[0].length;\n    const spans2 = [{\n      start: start2,\n      end: end2\n    }];\n    return normalizeSpan(spans2, text.length).map(chunk => ({\n      text: text.slice(chunk.start, chunk.end),\n      match: !!chunk.match\n    }));\n  }\n  const searchText = ignoreCase ? text.toLowerCase() : text;\n  const searchQuery = ignoreCase ? typeof query === \"string\" ? query.toLowerCase() : query : query;\n  const start = typeof searchText === \"string\" ? searchText.indexOf(searchQuery) : -1;\n  if (start === -1) {\n    return [{\n      text,\n      match: false\n    }];\n  }\n  const end = start + searchQuery.length;\n  const spans = [{\n    start,\n    end\n  }];\n  return normalizeSpan(spans, text.length).map(chunk => ({\n    text: text.slice(chunk.start, chunk.end),\n    match: !!chunk.match\n  }));\n}\n\n// src/highlight-multiple.ts\nvar buildRegex = (queryProp, flags, exactMatch) => {\n  const query = queryProp.filter(Boolean).map(text => escapeRegex(text));\n  const pattern = exactMatch ? `\\\\b(${query.join(\"|\")})\\\\b` : `(${query.join(\"|\")})`;\n  return new RegExp(pattern, flags);\n};\nvar getRegexFlags = (ignoreCase, matchAll = true) => `${ignoreCase ? \"i\" : \"\"}${matchAll ? \"g\" : \"\"}`;\nfunction highlightMultiple(props) {\n  const {\n    text,\n    query,\n    ignoreCase,\n    matchAll,\n    exactMatch\n  } = props;\n  if (query.length === 0) {\n    return [{\n      text,\n      match: false\n    }];\n  }\n  const flags = getRegexFlags(ignoreCase, matchAll);\n  const regex = buildRegex(Array.isArray(query) ? query : [query], flags, exactMatch);\n  const spans = [...text.matchAll(regex)].map(match => ({\n    start: match.index || 0,\n    end: (match.index || 0) + match[0].length\n  }));\n  return normalizeSpan(spans, props.text.length).map(chunk => ({\n    text: props.text.slice(chunk.start, chunk.end),\n    match: !!chunk.match\n  }));\n}\n\n// src/highlight.ts\nvar highlightWord = props => {\n  if (props.matchAll == null) {\n    props.matchAll = Array.isArray(props.query);\n  }\n  if (!props.matchAll && Array.isArray(props.query)) {\n    throw new Error(\"matchAll must be true when using multiple queries\");\n  }\n  return props.matchAll ? highlightMultiple(props) : highlightFirst(props);\n};\nexport { highlightWord };","map":{"version":3,"names":["normalizeSpan","spans","len","result","append","start","end","match","push","length","lastIndex","chunk","escapeRegex","term","replace","char","highlightFirst","props","text","query","ignoreCase","exactMatch","escapedQuery","regex","RegExp","index","start2","end2","spans2","map","slice","searchText","toLowerCase","searchQuery","indexOf","buildRegex","queryProp","flags","filter","Boolean","pattern","join","getRegexFlags","matchAll","highlightMultiple","Array","isArray","highlightWord","Error"],"sources":["/Users/ameliamagick/personal-finance-tracker/node_modules/@zag-js/highlight-word/dist/index.mjs"],"sourcesContent":["// src/normalize-span.ts\nvar normalizeSpan = (spans, len) => {\n  const result = [];\n  const append = (start, end, match) => {\n    if (end - start > 0) result.push({ start, end, match });\n  };\n  if (spans.length === 0) {\n    append(0, len, false);\n  } else {\n    let lastIndex = 0;\n    for (const chunk of spans) {\n      append(lastIndex, chunk.start, false);\n      append(chunk.start, chunk.end, true);\n      lastIndex = chunk.end;\n    }\n    append(lastIndex, len, false);\n  }\n  return result;\n};\n\n// src/escape-regex.ts\nvar escapeRegex = (term) => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, (char) => `\\\\${char}`);\n\n// src/highlight-first.ts\nfunction highlightFirst(props) {\n  const { text, query, ignoreCase, exactMatch } = props;\n  if (exactMatch) {\n    const escapedQuery = escapeRegex(query);\n    const regex = new RegExp(`\\\\b(${escapedQuery})\\\\b`, ignoreCase ? \"i\" : \"\");\n    const match = text.match(regex);\n    if (!match || match.index === void 0) {\n      return [{ text, match: false }];\n    }\n    const start2 = match.index;\n    const end2 = start2 + match[0].length;\n    const spans2 = [{ start: start2, end: end2 }];\n    return normalizeSpan(spans2, text.length).map((chunk) => ({\n      text: text.slice(chunk.start, chunk.end),\n      match: !!chunk.match\n    }));\n  }\n  const searchText = ignoreCase ? text.toLowerCase() : text;\n  const searchQuery = ignoreCase ? typeof query === \"string\" ? query.toLowerCase() : query : query;\n  const start = typeof searchText === \"string\" ? searchText.indexOf(searchQuery) : -1;\n  if (start === -1) {\n    return [{ text, match: false }];\n  }\n  const end = start + searchQuery.length;\n  const spans = [{ start, end }];\n  return normalizeSpan(spans, text.length).map((chunk) => ({\n    text: text.slice(chunk.start, chunk.end),\n    match: !!chunk.match\n  }));\n}\n\n// src/highlight-multiple.ts\nvar buildRegex = (queryProp, flags, exactMatch) => {\n  const query = queryProp.filter(Boolean).map((text) => escapeRegex(text));\n  const pattern = exactMatch ? `\\\\b(${query.join(\"|\")})\\\\b` : `(${query.join(\"|\")})`;\n  return new RegExp(pattern, flags);\n};\nvar getRegexFlags = (ignoreCase, matchAll = true) => `${ignoreCase ? \"i\" : \"\"}${matchAll ? \"g\" : \"\"}`;\nfunction highlightMultiple(props) {\n  const { text, query, ignoreCase, matchAll, exactMatch } = props;\n  if (query.length === 0) {\n    return [{ text, match: false }];\n  }\n  const flags = getRegexFlags(ignoreCase, matchAll);\n  const regex = buildRegex(Array.isArray(query) ? query : [query], flags, exactMatch);\n  const spans = [...text.matchAll(regex)].map((match) => ({\n    start: match.index || 0,\n    end: (match.index || 0) + match[0].length\n  }));\n  return normalizeSpan(spans, props.text.length).map((chunk) => ({\n    text: props.text.slice(chunk.start, chunk.end),\n    match: !!chunk.match\n  }));\n}\n\n// src/highlight.ts\nvar highlightWord = (props) => {\n  if (props.matchAll == null) {\n    props.matchAll = Array.isArray(props.query);\n  }\n  if (!props.matchAll && Array.isArray(props.query)) {\n    throw new Error(\"matchAll must be true when using multiple queries\");\n  }\n  return props.matchAll ? highlightMultiple(props) : highlightFirst(props);\n};\n\nexport { highlightWord };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}