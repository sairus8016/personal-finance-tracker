{"ast":null,"code":"\"use strict\";\n\nimport { compact } from '../utils/compact.js';\nimport { createProps } from '../utils/create-props.js';\nimport { mapEntries } from '../utils/entries.js';\nimport { isString, isObject, isFunction } from '../utils/is.js';\nimport { memo } from '../utils/memo.js';\nimport { mapObject, walkObject } from '../utils/walk-object.js';\nimport { cssVar } from './css-var.js';\nimport { esc } from './esc.js';\nimport { expandTokenReferences } from './expand-reference.js';\nimport { mapToJson } from './map-to-json.js';\nimport { hasReference, expandReferences, getReferences, TOKEN_PATH_REGEX } from './references.js';\nimport { tokenMiddlewares } from './token-middleware.js';\nimport { tokenTransforms } from './token-transforms.js';\nconst isToken = value => {\n  return isObject(value) && Object.prototype.hasOwnProperty.call(value, \"value\");\n};\nfunction expandBreakpoints(breakpoints) {\n  if (!breakpoints) return {\n    breakpoints: {},\n    sizes: {}\n  };\n  return {\n    breakpoints: mapObject(breakpoints, value => ({\n      value\n    })),\n    sizes: mapEntries(breakpoints, (key, value) => [`breakpoint-${key}`, {\n      value\n    }])\n  };\n}\nfunction createTokenDictionary(options) {\n  const {\n    prefix = \"\",\n    tokens = {},\n    semanticTokens = {},\n    breakpoints = {}\n  } = options;\n  const formatTokenName = path => path.join(\".\");\n  const formatCssVar = (path, prefix2) => cssVar(path.join(\"-\"), {\n    prefix: prefix2\n  });\n  const allTokens = [];\n  const tokenNameMap = /* @__PURE__ */new Map();\n  const conditionMap = /* @__PURE__ */new Map();\n  const cssVarMap = /* @__PURE__ */new Map();\n  const colorPaletteMap = /* @__PURE__ */new Map();\n  const flatMap = /* @__PURE__ */new Map();\n  const byCategory = /* @__PURE__ */new Map();\n  const categoryMap = /* @__PURE__ */new Map();\n  const transforms = /* @__PURE__ */new Map();\n  const middlewares = [];\n  function registerToken(token, phase) {\n    allTokens.push(token);\n    tokenNameMap.set(token.name, token);\n    if (phase) {\n      transforms.forEach(fn => {\n        if (fn.enforce === phase) transformToken(fn, token);\n      });\n    }\n  }\n  const breakpointTokens = expandBreakpoints(breakpoints);\n  const computedTokens = compact({\n    ...tokens,\n    breakpoints: breakpointTokens.breakpoints,\n    sizes: {\n      ...tokens.sizes,\n      ...breakpointTokens.sizes\n    }\n  });\n  function registerTokens() {\n    walkObject(computedTokens, (entry, path) => {\n      const isDefault = path.includes(\"DEFAULT\");\n      path = filterDefault(path);\n      const category = path[0];\n      const name = formatTokenName(path);\n      const t = isString(entry) ? {\n        value: entry\n      } : entry;\n      const token = {\n        value: t.value,\n        originalValue: t.value,\n        name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category,\n          prop: formatTokenName(path.slice(1))\n        }\n      };\n      if (isDefault) {\n        token.extensions.default = true;\n      }\n      registerToken(token);\n    }, {\n      stop: isToken\n    });\n    walkObject(semanticTokens, (entry, path) => {\n      const isDefault = path.includes(\"DEFAULT\");\n      path = filterBaseCondition(filterDefault(path));\n      const category = path[0];\n      const name = formatTokenName(path);\n      const t = isString(entry.value) ? {\n        value: {\n          base: entry.value\n        }\n      } : entry;\n      const token = {\n        value: t.value.base || \"\",\n        originalValue: t.value.base || \"\",\n        name,\n        path,\n        extensions: {\n          originalPath: path,\n          category,\n          conditions: t.value,\n          condition: \"base\",\n          prop: formatTokenName(path.slice(1))\n        }\n      };\n      if (isDefault) {\n        token.extensions.default = true;\n      }\n      registerToken(token);\n    }, {\n      stop: isToken\n    });\n  }\n  function getByName(name) {\n    return tokenNameMap.get(name);\n  }\n  function buildConditionMap(token) {\n    const {\n      condition\n    } = token.extensions;\n    if (!condition) return;\n    if (!conditionMap.has(condition)) {\n      conditionMap.set(condition, /* @__PURE__ */new Set());\n    }\n    conditionMap.get(condition).add(token);\n  }\n  function buildCategoryMap(token) {\n    const {\n      category,\n      prop\n    } = token.extensions;\n    if (!category) return;\n    if (!categoryMap.has(category)) {\n      categoryMap.set(category, /* @__PURE__ */new Map());\n    }\n    categoryMap.get(category).set(prop, token);\n  }\n  function buildCssVars(token) {\n    const {\n      condition,\n      negative,\n      virtual,\n      cssVar: cssVar2\n    } = token.extensions;\n    if (negative || virtual || !condition || !cssVar2) return;\n    if (!cssVarMap.has(condition)) {\n      cssVarMap.set(condition, /* @__PURE__ */new Map());\n    }\n    cssVarMap.get(condition).set(cssVar2.var, token.value);\n  }\n  function buildFlatMap(token) {\n    const {\n      category,\n      prop,\n      cssVar: cssVar2,\n      negative\n    } = token.extensions;\n    if (!category) return;\n    if (!byCategory.has(category)) {\n      byCategory.set(category, /* @__PURE__ */new Map());\n    }\n    const value = negative ? token.extensions.conditions ? token.originalValue : token.value : cssVar2.ref;\n    byCategory.get(category).set(prop, value);\n    flatMap.set([category, prop].join(\".\"), value);\n  }\n  function buildColorPalette(token) {\n    const {\n      colorPalette,\n      virtual,\n      default: isDefault\n    } = token.extensions;\n    if (!colorPalette || virtual) return;\n    colorPalette.roots.forEach(root => {\n      const name = formatTokenName(root);\n      if (!colorPaletteMap.has(name)) {\n        colorPaletteMap.set(name, /* @__PURE__ */new Map());\n      }\n      const virtualPath = replaceRootWithColorPalette([...token.path], [...root]);\n      const virtualName = formatTokenName(virtualPath);\n      const virtualToken = getByName(virtualName);\n      if (!virtualToken || !virtualToken.extensions.cssVar) return;\n      const {\n        var: virtualVar\n      } = virtualToken.extensions.cssVar;\n      colorPaletteMap.get(name).set(virtualVar, token.extensions.cssVar.ref);\n      if (isDefault && root.length === 1) {\n        const colorPaletteName = formatTokenName([\"colors\", \"colorPalette\"]);\n        const colorPaletteToken = getByName(colorPaletteName);\n        if (!colorPaletteToken) return;\n        const name2 = formatTokenName(token.path);\n        const virtualToken2 = getByName(name2);\n        if (!virtualToken2) return;\n        const keyPath = colorPalette.keys[0]?.filter(Boolean);\n        if (!keyPath.length) return;\n        const computedName = formatTokenName(root.concat(keyPath));\n        if (!colorPaletteMap.has(computedName)) {\n          colorPaletteMap.set(computedName, /* @__PURE__ */new Map());\n        }\n        colorPaletteMap.get(computedName).set(colorPaletteToken.extensions.cssVar.var, virtualToken2.extensions.cssVar.ref);\n      }\n    });\n  }\n  let byCategoryJson = {};\n  function setupViews() {\n    allTokens.forEach(token => {\n      buildConditionMap(token);\n      buildCategoryMap(token);\n      buildCssVars(token);\n      buildFlatMap(token);\n      buildColorPalette(token);\n    });\n    byCategoryJson = mapToJson(byCategory);\n  }\n  const colorMix = (value, tokenFn) => {\n    if (!value || typeof value !== \"string\") return {\n      invalid: true,\n      value\n    };\n    const [colorPath, rawOpacity] = value.split(\"/\");\n    if (!colorPath || !rawOpacity) {\n      return {\n        invalid: true,\n        value: colorPath\n      };\n    }\n    const colorToken = tokenFn(colorPath);\n    const opacityToken = getByName(`opacity.${rawOpacity}`)?.value;\n    if (!opacityToken && isNaN(Number(rawOpacity))) {\n      return {\n        invalid: true,\n        value: colorPath\n      };\n    }\n    const percent = opacityToken ? Number(opacityToken) * 100 + \"%\" : `${rawOpacity}%`;\n    const color = colorToken ?? colorPath;\n    return {\n      invalid: false,\n      color,\n      value: `color-mix(in srgb, ${color} ${percent}, transparent)`\n    };\n  };\n  const getVar = memo((value, fallback) => {\n    return flatMap.get(value) ?? fallback;\n  });\n  const getCategoryValues = memo(category => {\n    return byCategoryJson[category] || null;\n  });\n  const expandReferenceInValue = memo(value => {\n    return expandTokenReferences(value, path => {\n      if (!path) return;\n      if (path.includes(\"/\")) {\n        const mix = colorMix(path, v => getVar(v));\n        if (mix.invalid) {\n          throw new Error(\"Invalid color mix at \" + path + \": \" + mix.value);\n        }\n        return mix.value;\n      }\n      const resolved = getVar(path);\n      if (resolved) return resolved;\n      return TOKEN_PATH_REGEX.test(path) ? esc(path) : path;\n    });\n  });\n  const dictionary = {\n    prefix,\n    allTokens,\n    tokenMap: tokenNameMap,\n    registerToken,\n    getByName,\n    formatTokenName,\n    formatCssVar,\n    flatMap,\n    cssVarMap,\n    categoryMap,\n    colorPaletteMap,\n    getVar,\n    getCategoryValues,\n    expandReferenceInValue\n  };\n  function registerTransform(...fns) {\n    fns.forEach(fn => {\n      transforms.set(fn.name, fn);\n    });\n  }\n  function registerMiddleware(...fns) {\n    middlewares.push(...fns);\n  }\n  function transformToken(transform, token) {\n    if (token.extensions.references) return;\n    if (isFunction(transform.match) && !transform.match(token)) return;\n    const fn = v => transform.transform(v, dictionary);\n    const transformed = fn(token);\n    switch (true) {\n      case transform.type === \"extensions\":\n        Object.assign(token.extensions, transformed);\n        break;\n      case transform.type === \"value\":\n        token.value = transformed;\n        break;\n      default:\n        token[transform.type] = transformed;\n        break;\n    }\n  }\n  function applyMiddlewares(enforce) {\n    middlewares.forEach(middleware => {\n      if (middleware.enforce === enforce) {\n        middleware.transform(dictionary);\n      }\n    });\n  }\n  function applyTransforms(enforce) {\n    transforms.forEach(transform => {\n      if (transform.enforce === enforce) {\n        allTokens.forEach(token => {\n          transformToken(transform, token);\n        });\n      }\n    });\n  }\n  function addConditionalTokens() {\n    allTokens.forEach(token => {\n      const tokens2 = getConditionalTokens(token);\n      if (!tokens2 || tokens2.length === 0) return;\n      tokens2.forEach(token2 => {\n        registerToken(token2);\n      });\n    });\n  }\n  function getTokenReferences(value) {\n    const refs = getReferences(value);\n    return refs.map(ref => getByName(ref)).filter(Boolean);\n  }\n  function addReferences() {\n    allTokens.forEach(token => {\n      if (!hasReference(token.value)) return;\n      const references = getTokenReferences(token.value);\n      token.extensions.references = references.reduce((acc, ref) => {\n        acc[ref.name] = ref;\n        return acc;\n      }, {});\n    });\n  }\n  function expandTokenReferences$1() {\n    allTokens.forEach(token => {\n      expandReferences(token);\n    });\n  }\n  function build() {\n    applyMiddlewares(\"pre\");\n    applyTransforms(\"pre\");\n    addConditionalTokens();\n    addReferences();\n    expandTokenReferences$1();\n    applyMiddlewares(\"post\");\n    applyTransforms(\"post\");\n    setupViews();\n  }\n  registerTokens();\n  registerTransform(...tokenTransforms);\n  registerMiddleware(...tokenMiddlewares);\n  build();\n  return dictionary;\n}\nfunction filterDefault(path) {\n  if (path[0] === \"DEFAULT\") return path;\n  return path.filter(item => item !== \"DEFAULT\");\n}\nfunction filterBaseCondition(path) {\n  return path.filter(item => item !== \"base\");\n}\nfunction getConditionalTokens(token) {\n  if (!token.extensions.conditions) return;\n  const {\n    conditions\n  } = token.extensions;\n  const tokens = [];\n  walkObject(conditions, (value, path) => {\n    const nextPath = filterBaseCondition(path);\n    if (!nextPath.length) return;\n    const nextToken = structuredClone(token);\n    nextToken.value = value;\n    nextToken.extensions.condition = nextPath.join(\":\");\n    tokens.push(nextToken);\n  });\n  return tokens;\n}\nfunction replaceRootWithColorPalette(path, roots) {\n  const startIndex = path.findIndex((_, index) => roots.every((rootElement, rootIndex) => path[index + rootIndex] === rootElement));\n  if (startIndex === -1) {\n    return path;\n  }\n  path.splice(startIndex, roots.length);\n  path.splice(startIndex, 0, \"colorPalette\");\n  return path;\n}\nconst tokenCategories = createProps()([\"aspectRatios\", \"zIndex\", \"opacity\", \"colors\", \"fonts\", \"fontSizes\", \"fontWeights\", \"lineHeights\", \"letterSpacings\", \"sizes\", \"shadows\", \"spacing\", \"radii\", \"cursor\", \"borders\", \"borderWidths\", \"borderStyles\", \"durations\", \"easings\", \"animations\", \"blurs\", \"gradients\", \"breakpoints\", \"assets\"]);\nexport { createTokenDictionary, tokenCategories };","map":{"version":3,"names":["compact","createProps","mapEntries","isString","isObject","isFunction","memo","mapObject","walkObject","cssVar","esc","expandTokenReferences","mapToJson","hasReference","expandReferences","getReferences","TOKEN_PATH_REGEX","tokenMiddlewares","tokenTransforms","isToken","value","Object","prototype","hasOwnProperty","call","expandBreakpoints","breakpoints","sizes","key","createTokenDictionary","options","prefix","tokens","semanticTokens","formatTokenName","path","join","formatCssVar","prefix2","allTokens","tokenNameMap","Map","conditionMap","cssVarMap","colorPaletteMap","flatMap","byCategory","categoryMap","transforms","middlewares","registerToken","token","phase","push","set","name","forEach","fn","enforce","transformToken","breakpointTokens","computedTokens","registerTokens","entry","isDefault","includes","filterDefault","category","t","originalValue","extensions","condition","originalPath","prop","slice","default","stop","filterBaseCondition","base","conditions","getByName","get","buildConditionMap","has","Set","add","buildCategoryMap","buildCssVars","negative","virtual","cssVar2","var","buildFlatMap","ref","buildColorPalette","colorPalette","roots","root","virtualPath","replaceRootWithColorPalette","virtualName","virtualToken","virtualVar","length","colorPaletteName","colorPaletteToken","name2","virtualToken2","keyPath","keys","filter","Boolean","computedName","concat","byCategoryJson","setupViews","colorMix","tokenFn","invalid","colorPath","rawOpacity","split","colorToken","opacityToken","isNaN","Number","percent","color","getVar","fallback","getCategoryValues","expandReferenceInValue","mix","v","Error","resolved","test","dictionary","tokenMap","registerTransform","fns","registerMiddleware","transform","references","match","transformed","type","assign","applyMiddlewares","middleware","applyTransforms","addConditionalTokens","tokens2","getConditionalTokens","token2","getTokenReferences","refs","map","addReferences","reduce","acc","expandTokenReferences$1","build","item","nextPath","nextToken","structuredClone","startIndex","findIndex","_","index","every","rootElement","rootIndex","splice","tokenCategories"],"sources":["/Users/ameliamagick/personal-finance-tracker/node_modules/@chakra-ui/react/dist/esm/styled-system/token-dictionary.js"],"sourcesContent":["\"use strict\";\nimport { compact } from '../utils/compact.js';\nimport { createProps } from '../utils/create-props.js';\nimport { mapEntries } from '../utils/entries.js';\nimport { isString, isObject, isFunction } from '../utils/is.js';\nimport { memo } from '../utils/memo.js';\nimport { mapObject, walkObject } from '../utils/walk-object.js';\nimport { cssVar } from './css-var.js';\nimport { esc } from './esc.js';\nimport { expandTokenReferences } from './expand-reference.js';\nimport { mapToJson } from './map-to-json.js';\nimport { hasReference, expandReferences, getReferences, TOKEN_PATH_REGEX } from './references.js';\nimport { tokenMiddlewares } from './token-middleware.js';\nimport { tokenTransforms } from './token-transforms.js';\n\nconst isToken = (value) => {\n  return isObject(value) && Object.prototype.hasOwnProperty.call(value, \"value\");\n};\nfunction expandBreakpoints(breakpoints) {\n  if (!breakpoints) return { breakpoints: {}, sizes: {} };\n  return {\n    breakpoints: mapObject(breakpoints, (value) => ({ value })),\n    sizes: mapEntries(breakpoints, (key, value) => [\n      `breakpoint-${key}`,\n      { value }\n    ])\n  };\n}\nfunction createTokenDictionary(options) {\n  const {\n    prefix = \"\",\n    tokens = {},\n    semanticTokens = {},\n    breakpoints = {}\n  } = options;\n  const formatTokenName = (path) => path.join(\".\");\n  const formatCssVar = (path, prefix2) => cssVar(path.join(\"-\"), { prefix: prefix2 });\n  const allTokens = [];\n  const tokenNameMap = /* @__PURE__ */ new Map();\n  const conditionMap = /* @__PURE__ */ new Map();\n  const cssVarMap = /* @__PURE__ */ new Map();\n  const colorPaletteMap = /* @__PURE__ */ new Map();\n  const flatMap = /* @__PURE__ */ new Map();\n  const byCategory = /* @__PURE__ */ new Map();\n  const categoryMap = /* @__PURE__ */ new Map();\n  const transforms = /* @__PURE__ */ new Map();\n  const middlewares = [];\n  function registerToken(token, phase) {\n    allTokens.push(token);\n    tokenNameMap.set(token.name, token);\n    if (phase) {\n      transforms.forEach((fn) => {\n        if (fn.enforce === phase) transformToken(fn, token);\n      });\n    }\n  }\n  const breakpointTokens = expandBreakpoints(breakpoints);\n  const computedTokens = compact({\n    ...tokens,\n    breakpoints: breakpointTokens.breakpoints,\n    sizes: {\n      ...tokens.sizes,\n      ...breakpointTokens.sizes\n    }\n  });\n  function registerTokens() {\n    walkObject(\n      computedTokens,\n      (entry, path) => {\n        const isDefault = path.includes(\"DEFAULT\");\n        path = filterDefault(path);\n        const category = path[0];\n        const name = formatTokenName(path);\n        const t = isString(entry) ? { value: entry } : entry;\n        const token = {\n          value: t.value,\n          originalValue: t.value,\n          name,\n          path,\n          extensions: {\n            condition: \"base\",\n            originalPath: path,\n            category,\n            prop: formatTokenName(path.slice(1))\n          }\n        };\n        if (isDefault) {\n          token.extensions.default = true;\n        }\n        registerToken(token);\n      },\n      { stop: isToken }\n    );\n    walkObject(\n      semanticTokens,\n      (entry, path) => {\n        const isDefault = path.includes(\"DEFAULT\");\n        path = filterBaseCondition(filterDefault(path));\n        const category = path[0];\n        const name = formatTokenName(path);\n        const t = isString(entry.value) ? { value: { base: entry.value } } : entry;\n        const token = {\n          value: t.value.base || \"\",\n          originalValue: t.value.base || \"\",\n          name,\n          path,\n          extensions: {\n            originalPath: path,\n            category,\n            conditions: t.value,\n            condition: \"base\",\n            prop: formatTokenName(path.slice(1))\n          }\n        };\n        if (isDefault) {\n          token.extensions.default = true;\n        }\n        registerToken(token);\n      },\n      { stop: isToken }\n    );\n  }\n  function getByName(name) {\n    return tokenNameMap.get(name);\n  }\n  function buildConditionMap(token) {\n    const { condition } = token.extensions;\n    if (!condition) return;\n    if (!conditionMap.has(condition)) {\n      conditionMap.set(condition, /* @__PURE__ */ new Set());\n    }\n    conditionMap.get(condition).add(token);\n  }\n  function buildCategoryMap(token) {\n    const { category, prop } = token.extensions;\n    if (!category) return;\n    if (!categoryMap.has(category)) {\n      categoryMap.set(category, /* @__PURE__ */ new Map());\n    }\n    categoryMap.get(category).set(prop, token);\n  }\n  function buildCssVars(token) {\n    const { condition, negative, virtual, cssVar: cssVar2 } = token.extensions;\n    if (negative || virtual || !condition || !cssVar2) return;\n    if (!cssVarMap.has(condition)) {\n      cssVarMap.set(condition, /* @__PURE__ */ new Map());\n    }\n    cssVarMap.get(condition).set(cssVar2.var, token.value);\n  }\n  function buildFlatMap(token) {\n    const { category, prop, cssVar: cssVar2, negative } = token.extensions;\n    if (!category) return;\n    if (!byCategory.has(category)) {\n      byCategory.set(category, /* @__PURE__ */ new Map());\n    }\n    const value = negative ? token.extensions.conditions ? token.originalValue : token.value : cssVar2.ref;\n    byCategory.get(category).set(prop, value);\n    flatMap.set([category, prop].join(\".\"), value);\n  }\n  function buildColorPalette(token) {\n    const { colorPalette, virtual, default: isDefault } = token.extensions;\n    if (!colorPalette || virtual) return;\n    colorPalette.roots.forEach((root) => {\n      const name = formatTokenName(root);\n      if (!colorPaletteMap.has(name)) {\n        colorPaletteMap.set(name, /* @__PURE__ */ new Map());\n      }\n      const virtualPath = replaceRootWithColorPalette(\n        [...token.path],\n        [...root]\n      );\n      const virtualName = formatTokenName(virtualPath);\n      const virtualToken = getByName(virtualName);\n      if (!virtualToken || !virtualToken.extensions.cssVar) return;\n      const { var: virtualVar } = virtualToken.extensions.cssVar;\n      colorPaletteMap.get(name).set(virtualVar, token.extensions.cssVar.ref);\n      if (isDefault && root.length === 1) {\n        const colorPaletteName = formatTokenName([\"colors\", \"colorPalette\"]);\n        const colorPaletteToken = getByName(colorPaletteName);\n        if (!colorPaletteToken) return;\n        const name2 = formatTokenName(token.path);\n        const virtualToken2 = getByName(name2);\n        if (!virtualToken2) return;\n        const keyPath = colorPalette.keys[0]?.filter(Boolean);\n        if (!keyPath.length) return;\n        const computedName = formatTokenName(root.concat(keyPath));\n        if (!colorPaletteMap.has(computedName)) {\n          colorPaletteMap.set(computedName, /* @__PURE__ */ new Map());\n        }\n        colorPaletteMap.get(computedName).set(\n          colorPaletteToken.extensions.cssVar.var,\n          virtualToken2.extensions.cssVar.ref\n        );\n      }\n    });\n  }\n  let byCategoryJson = {};\n  function setupViews() {\n    allTokens.forEach((token) => {\n      buildConditionMap(token);\n      buildCategoryMap(token);\n      buildCssVars(token);\n      buildFlatMap(token);\n      buildColorPalette(token);\n    });\n    byCategoryJson = mapToJson(byCategory);\n  }\n  const colorMix = (value, tokenFn) => {\n    if (!value || typeof value !== \"string\") return { invalid: true, value };\n    const [colorPath, rawOpacity] = value.split(\"/\");\n    if (!colorPath || !rawOpacity) {\n      return { invalid: true, value: colorPath };\n    }\n    const colorToken = tokenFn(colorPath);\n    const opacityToken = getByName(`opacity.${rawOpacity}`)?.value;\n    if (!opacityToken && isNaN(Number(rawOpacity))) {\n      return { invalid: true, value: colorPath };\n    }\n    const percent = opacityToken ? Number(opacityToken) * 100 + \"%\" : `${rawOpacity}%`;\n    const color = colorToken ?? colorPath;\n    return {\n      invalid: false,\n      color,\n      value: `color-mix(in srgb, ${color} ${percent}, transparent)`\n    };\n  };\n  const getVar = memo((value, fallback) => {\n    return flatMap.get(value) ?? fallback;\n  });\n  const getCategoryValues = memo((category) => {\n    return byCategoryJson[category] || null;\n  });\n  const expandReferenceInValue = memo((value) => {\n    return expandTokenReferences(value, (path) => {\n      if (!path) return;\n      if (path.includes(\"/\")) {\n        const mix = colorMix(path, (v) => getVar(v));\n        if (mix.invalid) {\n          throw new Error(\"Invalid color mix at \" + path + \": \" + mix.value);\n        }\n        return mix.value;\n      }\n      const resolved = getVar(path);\n      if (resolved) return resolved;\n      return TOKEN_PATH_REGEX.test(path) ? esc(path) : path;\n    });\n  });\n  const dictionary = {\n    prefix,\n    allTokens,\n    tokenMap: tokenNameMap,\n    registerToken,\n    getByName,\n    formatTokenName,\n    formatCssVar,\n    flatMap,\n    cssVarMap,\n    categoryMap,\n    colorPaletteMap,\n    getVar,\n    getCategoryValues,\n    expandReferenceInValue\n  };\n  function registerTransform(...fns) {\n    fns.forEach((fn) => {\n      transforms.set(fn.name, fn);\n    });\n  }\n  function registerMiddleware(...fns) {\n    middlewares.push(...fns);\n  }\n  function transformToken(transform, token) {\n    if (token.extensions.references) return;\n    if (isFunction(transform.match) && !transform.match(token)) return;\n    const fn = (v) => transform.transform(v, dictionary);\n    const transformed = fn(token);\n    switch (true) {\n      case transform.type === \"extensions\":\n        Object.assign(token.extensions, transformed);\n        break;\n      case transform.type === \"value\":\n        token.value = transformed;\n        break;\n      default:\n        token[transform.type] = transformed;\n        break;\n    }\n  }\n  function applyMiddlewares(enforce) {\n    middlewares.forEach((middleware) => {\n      if (middleware.enforce === enforce) {\n        middleware.transform(dictionary);\n      }\n    });\n  }\n  function applyTransforms(enforce) {\n    transforms.forEach((transform) => {\n      if (transform.enforce === enforce) {\n        allTokens.forEach((token) => {\n          transformToken(transform, token);\n        });\n      }\n    });\n  }\n  function addConditionalTokens() {\n    allTokens.forEach((token) => {\n      const tokens2 = getConditionalTokens(token);\n      if (!tokens2 || tokens2.length === 0) return;\n      tokens2.forEach((token2) => {\n        registerToken(token2);\n      });\n    });\n  }\n  function getTokenReferences(value) {\n    const refs = getReferences(value);\n    return refs.map((ref) => getByName(ref)).filter(Boolean);\n  }\n  function addReferences() {\n    allTokens.forEach((token) => {\n      if (!hasReference(token.value)) return;\n      const references = getTokenReferences(token.value);\n      token.extensions.references = references.reduce((acc, ref) => {\n        acc[ref.name] = ref;\n        return acc;\n      }, {});\n    });\n  }\n  function expandTokenReferences$1() {\n    allTokens.forEach((token) => {\n      expandReferences(token);\n    });\n  }\n  function build() {\n    applyMiddlewares(\"pre\");\n    applyTransforms(\"pre\");\n    addConditionalTokens();\n    addReferences();\n    expandTokenReferences$1();\n    applyMiddlewares(\"post\");\n    applyTransforms(\"post\");\n    setupViews();\n  }\n  registerTokens();\n  registerTransform(...tokenTransforms);\n  registerMiddleware(...tokenMiddlewares);\n  build();\n  return dictionary;\n}\nfunction filterDefault(path) {\n  if (path[0] === \"DEFAULT\") return path;\n  return path.filter((item) => item !== \"DEFAULT\");\n}\nfunction filterBaseCondition(path) {\n  return path.filter((item) => item !== \"base\");\n}\nfunction getConditionalTokens(token) {\n  if (!token.extensions.conditions) return;\n  const { conditions } = token.extensions;\n  const tokens = [];\n  walkObject(conditions, (value, path) => {\n    const nextPath = filterBaseCondition(path);\n    if (!nextPath.length) return;\n    const nextToken = structuredClone(token);\n    nextToken.value = value;\n    nextToken.extensions.condition = nextPath.join(\":\");\n    tokens.push(nextToken);\n  });\n  return tokens;\n}\nfunction replaceRootWithColorPalette(path, roots) {\n  const startIndex = path.findIndex(\n    (_, index) => roots.every(\n      (rootElement, rootIndex) => path[index + rootIndex] === rootElement\n    )\n  );\n  if (startIndex === -1) {\n    return path;\n  }\n  path.splice(startIndex, roots.length);\n  path.splice(startIndex, 0, \"colorPalette\");\n  return path;\n}\nconst tokenCategories = createProps()([\n  \"aspectRatios\",\n  \"zIndex\",\n  \"opacity\",\n  \"colors\",\n  \"fonts\",\n  \"fontSizes\",\n  \"fontWeights\",\n  \"lineHeights\",\n  \"letterSpacings\",\n  \"sizes\",\n  \"shadows\",\n  \"spacing\",\n  \"radii\",\n  \"cursor\",\n  \"borders\",\n  \"borderWidths\",\n  \"borderStyles\",\n  \"durations\",\n  \"easings\",\n  \"animations\",\n  \"blurs\",\n  \"gradients\",\n  \"breakpoints\",\n  \"assets\"\n]);\n\nexport { createTokenDictionary, tokenCategories };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}