{"ast":null,"code":"import { getDocument, getControlledElements, isControlledElement, getTabbables, getFocusables, isTabbable, getTabIndex, addDomEvent, getActiveElement, raf, getEventTarget, isDocument, hasControllerElements, isControlledByExpandedController, isFocusable } from '@zag-js/dom-query';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar activeFocusTraps = {\n  activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      const activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap(trapStack, trap) {\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar sharedTrapStack = [];\nvar FocusTrap = class {\n  constructor(elements, options) {\n    __publicField(this, \"trapStack\");\n    __publicField(this, \"config\");\n    __publicField(this, \"doc\");\n    __publicField(this, \"state\", {\n      containers: [],\n      containerGroups: [],\n      tabbableGroups: [],\n      nodeFocusedBeforeActivation: null,\n      mostRecentlyFocusedNode: null,\n      active: false,\n      paused: false,\n      delayInitialFocusTimer: void 0,\n      recentNavEvent: void 0\n    });\n    // Track portal containers that contain controlled elements\n    __publicField(this, \"portalContainers\", /* @__PURE__ */new Set());\n    __publicField(this, \"listenerCleanups\", []);\n    __publicField(this, \"handleFocus\", event => {\n      const target = getEventTarget(event);\n      const targetContained = this.findContainerIndex(target, event) >= 0;\n      if (targetContained || isDocument(target)) {\n        if (targetContained) {\n          this.state.mostRecentlyFocusedNode = target;\n        }\n      } else {\n        event.stopImmediatePropagation();\n        let nextNode;\n        let navAcrossContainers = true;\n        if (this.state.mostRecentlyFocusedNode) {\n          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {\n            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);\n            const {\n              tabbableNodes\n            } = this.state.containerGroups[mruContainerIdx];\n            if (tabbableNodes.length > 0) {\n              const mruTabIdx = tabbableNodes.findIndex(node => node === this.state.mostRecentlyFocusedNode);\n              if (mruTabIdx >= 0) {\n                if (this.config.isKeyForward(this.state.recentNavEvent)) {\n                  if (mruTabIdx + 1 < tabbableNodes.length) {\n                    nextNode = tabbableNodes[mruTabIdx + 1];\n                    navAcrossContainers = false;\n                  }\n                } else {\n                  if (mruTabIdx - 1 >= 0) {\n                    nextNode = tabbableNodes[mruTabIdx - 1];\n                    navAcrossContainers = false;\n                  }\n                }\n              }\n            }\n          } else {\n            if (!this.state.containerGroups.some(g => g.tabbableNodes.some(n => getTabIndex(n) > 0))) {\n              navAcrossContainers = false;\n            }\n          }\n        } else {\n          navAcrossContainers = false;\n        }\n        if (navAcrossContainers) {\n          nextNode = this.findNextNavNode({\n            // move FROM the MRU node, not event-related node (which will be the node that is\n            //  outside the trap causing the focus escape we're trying to fix)\n            target: this.state.mostRecentlyFocusedNode,\n            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)\n          });\n        }\n        if (nextNode) {\n          this.tryFocus(nextNode);\n        } else {\n          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());\n        }\n      }\n      this.state.recentNavEvent = void 0;\n    });\n    __publicField(this, \"handlePointerDown\", event => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        this.deactivate({\n          returnFocus: this.config.returnFocusOnDeactivate\n        });\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n    });\n    __publicField(this, \"handleClick\", event => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n    __publicField(this, \"handleTabKey\", event => {\n      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {\n        this.state.recentNavEvent = event;\n        const isBackward = this.config.isKeyBackward(event);\n        const destinationNode = this.findNextNavNode({\n          event,\n          isBackward\n        });\n        if (!destinationNode) return;\n        if (isTabEvent(event)) {\n          event.preventDefault();\n        }\n        this.tryFocus(destinationNode);\n      }\n    });\n    __publicField(this, \"handleEscapeKey\", event => {\n      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {\n        event.preventDefault();\n        this.deactivate();\n      }\n    });\n    __publicField(this, \"_mutationObserver\");\n    __publicField(this, \"setupMutationObserver\", () => {\n      const win = this.doc.defaultView || window;\n      this._mutationObserver = new win.MutationObserver(mutations => {\n        const isFocusedNodeRemoved = mutations.some(mutation => {\n          const removedNodes = Array.from(mutation.removedNodes);\n          return removedNodes.some(node => node === this.state.mostRecentlyFocusedNode);\n        });\n        if (isFocusedNodeRemoved) {\n          this.tryFocus(this.getInitialFocusNode());\n        }\n        const hasControlledChanges = mutations.some(mutation => {\n          if (mutation.type === \"attributes\" && (mutation.attributeName === \"aria-controls\" || mutation.attributeName === \"aria-expanded\")) {\n            return true;\n          }\n          if (mutation.type === \"childList\" && mutation.addedNodes.length > 0) {\n            return Array.from(mutation.addedNodes).some(node => {\n              if (node.nodeType !== Node.ELEMENT_NODE) return false;\n              const element = node;\n              if (hasControllerElements(element)) {\n                return true;\n              }\n              if (element.id && !this.state.containers.some(c => c.contains(element))) {\n                return isControlledByExpandedController(element);\n              }\n              return false;\n            });\n          }\n          return false;\n        });\n        if (hasControlledChanges && this.state.active && !this.state.paused) {\n          this.updateTabbableNodes();\n          this.updatePortalContainers();\n        }\n      });\n    });\n    __publicField(this, \"updateObservedNodes\", () => {\n      this._mutationObserver?.disconnect();\n      if (this.state.active && !this.state.paused) {\n        this.state.containers.map(container => {\n          this._mutationObserver?.observe(container, {\n            subtree: true,\n            childList: true,\n            attributes: true,\n            attributeFilter: [\"aria-controls\", \"aria-expanded\"]\n          });\n        });\n        this.portalContainers.forEach(portalContainer => {\n          this.observePortalContainer(portalContainer);\n        });\n      }\n    });\n    __publicField(this, \"getInitialFocusNode\", () => {\n      let node = this.getNodeForOption(\"initialFocus\", {\n        hasFallback: true\n      });\n      if (node === false) {\n        return false;\n      }\n      if (node === void 0 || node && !isFocusable(node)) {\n        const activeElement = getActiveElement(this.doc);\n        if (activeElement && this.findContainerIndex(activeElement) >= 0) {\n          node = activeElement;\n        } else {\n          const firstTabbableGroup = this.state.tabbableGroups[0];\n          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n          node = firstTabbableNode || this.getNodeForOption(\"fallbackFocus\");\n        }\n      } else if (node === null) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      if (!node) {\n        throw new Error(\"Your focus-trap needs to have at least one focusable element\");\n      }\n      if (!node.isConnected) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return node;\n    });\n    __publicField(this, \"tryFocus\", node => {\n      if (node === false) return;\n      if (node === getActiveElement(this.doc)) return;\n      if (!node || !node.focus) {\n        this.tryFocus(this.getInitialFocusNode());\n        return;\n      }\n      node.focus({\n        preventScroll: !!this.config.preventScroll\n      });\n      this.state.mostRecentlyFocusedNode = node;\n      if (isSelectableInput(node)) {\n        node.select();\n      }\n    });\n    __publicField(this, \"deactivate\", deactivateOptions => {\n      if (!this.state.active) return this;\n      const options = {\n        onDeactivate: this.config.onDeactivate,\n        onPostDeactivate: this.config.onPostDeactivate,\n        checkCanReturnFocus: this.config.checkCanReturnFocus,\n        ...deactivateOptions\n      };\n      clearTimeout(this.state.delayInitialFocusTimer);\n      this.state.delayInitialFocusTimer = void 0;\n      this.removeListeners();\n      this.state.active = false;\n      this.state.paused = false;\n      this.updateObservedNodes();\n      activeFocusTraps.deactivateTrap(this.trapStack, this);\n      this.portalContainers.clear();\n      const onDeactivate = this.getOption(options, \"onDeactivate\");\n      const onPostDeactivate = this.getOption(options, \"onPostDeactivate\");\n      const checkCanReturnFocus = this.getOption(options, \"checkCanReturnFocus\");\n      const returnFocus = this.getOption(options, \"returnFocus\", \"returnFocusOnDeactivate\");\n      onDeactivate?.();\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n            this.tryFocus(returnFocusNode);\n          }\n          onPostDeactivate?.();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    });\n    __publicField(this, \"pause\", pauseOptions => {\n      if (this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onPause = this.getOption(pauseOptions, \"onPause\");\n      const onPostPause = this.getOption(pauseOptions, \"onPostPause\");\n      this.state.paused = true;\n      onPause?.();\n      this.removeListeners();\n      this.updateObservedNodes();\n      onPostPause?.();\n      return this;\n    });\n    __publicField(this, \"unpause\", unpauseOptions => {\n      if (!this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onUnpause = this.getOption(unpauseOptions, \"onUnpause\");\n      const onPostUnpause = this.getOption(unpauseOptions, \"onPostUnpause\");\n      this.state.paused = false;\n      onUnpause?.();\n      this.updateTabbableNodes();\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostUnpause?.();\n      return this;\n    });\n    __publicField(this, \"updateContainerElements\", containerElements => {\n      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);\n      if (this.state.active) {\n        this.updateTabbableNodes();\n      }\n      this.updateObservedNodes();\n      return this;\n    });\n    __publicField(this, \"getReturnFocusNode\", previousActiveElement => {\n      const node = this.getNodeForOption(\"setReturnFocus\", {\n        params: [previousActiveElement]\n      });\n      return node ? node : node === false ? false : previousActiveElement;\n    });\n    __publicField(this, \"getOption\", (configOverrideOptions, optionName, configOptionName) => {\n      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] :\n      // @ts-expect-error\n      this.config[configOptionName || optionName];\n    });\n    __publicField(this, \"getNodeForOption\", (optionName, {\n      hasFallback = false,\n      params = []\n    } = {}) => {\n      let optionValue = this.config[optionName];\n      if (typeof optionValue === \"function\") optionValue = optionValue(...params);\n      if (optionValue === true) optionValue = void 0;\n      if (!optionValue) {\n        if (optionValue === void 0 || optionValue === false) {\n          return optionValue;\n        }\n        throw new Error(`\\`${optionName}\\` was specified but was not a node, or did not return a node`);\n      }\n      let node = optionValue;\n      if (typeof optionValue === \"string\") {\n        try {\n          node = this.doc.querySelector(optionValue);\n        } catch (err) {\n          throw new Error(`\\`${optionName}\\` appears to be an invalid selector; error=\"${err.message}\"`);\n        }\n        if (!node) {\n          if (!hasFallback) {\n            throw new Error(`\\`${optionName}\\` as selector refers to no known node`);\n          }\n        }\n      }\n      return node;\n    });\n    __publicField(this, \"findNextNavNode\", opts => {\n      const {\n        event,\n        isBackward = false\n      } = opts;\n      const target = opts.target || getEventTarget(event);\n      this.updateTabbableNodes();\n      let destinationNode = null;\n      if (this.state.tabbableGroups.length > 0) {\n        const containerIndex = this.findContainerIndex(target, event);\n        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;\n        if (containerIndex < 0) {\n          if (isBackward) {\n            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;\n          } else {\n            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;\n          }\n        } else if (isBackward) {\n          let startOfGroupIndex = this.state.tabbableGroups.findIndex(({\n            firstTabbableNode\n          }) => target === firstTabbableNode);\n          if (startOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target, false))) {\n            startOfGroupIndex = containerIndex;\n          }\n          if (startOfGroupIndex >= 0) {\n            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target, false);\n          }\n        } else {\n          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(({\n            lastTabbableNode\n          }) => target === lastTabbableNode);\n          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target))) {\n            lastOfGroupIndex = containerIndex;\n          }\n          if (lastOfGroupIndex >= 0) {\n            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target);\n          }\n        }\n      } else {\n        destinationNode = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return destinationNode;\n    });\n    this.trapStack = options.trapStack || sharedTrapStack;\n    const config = {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true,\n      delayInitialFocus: true,\n      followControlledElements: true,\n      isKeyForward(e) {\n        return isTabEvent(e) && !e.shiftKey;\n      },\n      isKeyBackward(e) {\n        return isTabEvent(e) && e.shiftKey;\n      },\n      ...options\n    };\n    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);\n    this.config = config;\n    this.updateContainerElements(elements);\n    this.setupMutationObserver();\n  }\n  addPortalContainer(controlledElement) {\n    const portalContainer = controlledElement.parentElement;\n    if (portalContainer && !this.portalContainers.has(portalContainer)) {\n      this.portalContainers.add(portalContainer);\n      if (this.state.active && !this.state.paused) {\n        this.observePortalContainer(portalContainer);\n      }\n    }\n  }\n  observePortalContainer(portalContainer) {\n    this._mutationObserver?.observe(portalContainer, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"aria-controls\", \"aria-expanded\"]\n    });\n  }\n  updatePortalContainers() {\n    if (!this.config.followControlledElements) return;\n    this.state.containers.forEach(container => {\n      const controlledElements = getControlledElements(container);\n      controlledElements.forEach(controlledElement => {\n        this.addPortalContainer(controlledElement);\n      });\n    });\n  }\n  get active() {\n    return this.state.active;\n  }\n  get paused() {\n    return this.state.paused;\n  }\n  findContainerIndex(element, event) {\n    const composedPath = typeof event?.composedPath === \"function\" ? event.composedPath() : void 0;\n    return this.state.containerGroups.findIndex(({\n      container,\n      tabbableNodes\n    }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find(node => node === element) || this.isControlledElement(container, element));\n  }\n  isControlledElement(container, element) {\n    if (!this.config.followControlledElements) return false;\n    return isControlledElement(container, element);\n  }\n  updateTabbableNodes() {\n    this.state.containerGroups = this.state.containers.map(container => {\n      const tabbableNodes = getTabbables(container);\n      const focusableNodes = getFocusables(container);\n      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;\n      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;\n      const firstDomTabbableNode = focusableNodes.find(node => isTabbable(node));\n      const lastDomTabbableNode = focusableNodes.slice().reverse().find(node => isTabbable(node));\n      const posTabIndexesFound = !!tabbableNodes.find(node => getTabIndex(node) > 0);\n      function nextTabbableNode(node, forward = true) {\n        const nodeIdx = tabbableNodes.indexOf(node);\n        if (nodeIdx < 0) {\n          if (forward) {\n            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(el => isTabbable(el));\n          }\n          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(el => isTabbable(el));\n        }\n        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n      }\n      return {\n        container,\n        tabbableNodes,\n        focusableNodes,\n        posTabIndexesFound,\n        firstTabbableNode,\n        lastTabbableNode,\n        firstDomTabbableNode,\n        lastDomTabbableNode,\n        nextTabbableNode\n      };\n    });\n    this.state.tabbableGroups = this.state.containerGroups.filter(group => group.tabbableNodes.length > 0);\n    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption(\"fallbackFocus\")) {\n      throw new Error(\"Your focus-trap must have at least one container with at least one tabbable node in it at all times\");\n    }\n    if (this.state.containerGroups.find(g => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  }\n  addListeners() {\n    if (!this.state.active) return;\n    activeFocusTraps.activateTrap(this.trapStack, this);\n    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {\n      this.tryFocus(this.getInitialFocusNode());\n    }) : this.tryFocus(this.getInitialFocusNode());\n    this.listenerCleanups.push(addDomEvent(this.doc, \"focusin\", this.handleFocus, true), addDomEvent(this.doc, \"mousedown\", this.handlePointerDown, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"touchstart\", this.handlePointerDown, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"click\", this.handleClick, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"keydown\", this.handleTabKey, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"keydown\", this.handleEscapeKey));\n    return this;\n  }\n  removeListeners() {\n    if (!this.state.active) return;\n    this.listenerCleanups.forEach(cleanup => cleanup());\n    this.listenerCleanups = [];\n    return this;\n  }\n  activate(activateOptions) {\n    if (this.state.active) {\n      return this;\n    }\n    const onActivate = this.getOption(activateOptions, \"onActivate\");\n    const onPostActivate = this.getOption(activateOptions, \"onPostActivate\");\n    const checkCanFocusTrap = this.getOption(activateOptions, \"checkCanFocusTrap\");\n    if (!checkCanFocusTrap) {\n      this.updateTabbableNodes();\n    }\n    this.state.active = true;\n    this.state.paused = false;\n    this.state.nodeFocusedBeforeActivation = getActiveElement(this.doc);\n    onActivate?.();\n    const finishActivation = () => {\n      if (checkCanFocusTrap) {\n        this.updateTabbableNodes();\n      }\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostActivate?.();\n    };\n    if (checkCanFocusTrap) {\n      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);\n      return this;\n    }\n    finishActivation();\n    return this;\n  }\n};\nvar isTabEvent = event => event.key === \"Tab\";\nvar valueOrHandler = (value, ...params) => typeof value === \"function\" ? value(...params) : value;\nvar isEscapeEvent = event => !event.isComposing && event.key === \"Escape\";\nvar delay = fn => setTimeout(fn, 0);\nvar isSelectableInput = node => node.localName === \"input\" && \"select\" in node && typeof node.select === \"function\";\n\n// src/index.ts\nfunction trapFocus(el, options = {}) {\n  let trap;\n  const cleanup = raf(() => {\n    const contentEl = typeof el === \"function\" ? el() : el;\n    if (!contentEl) return;\n    trap = new FocusTrap(contentEl, {\n      escapeDeactivates: false,\n      allowOutsideClick: true,\n      preventScroll: true,\n      returnFocusOnDeactivate: true,\n      delayInitialFocus: false,\n      fallbackFocus: contentEl,\n      ...options,\n      document: getDocument(contentEl)\n    });\n    try {\n      trap.activate();\n    } catch {}\n  });\n  return function destroy() {\n    trap?.deactivate();\n    cleanup();\n  };\n}\nexport { FocusTrap, trapFocus };","map":{"version":3,"names":["getDocument","getControlledElements","isControlledElement","getTabbables","getFocusables","isTabbable","getTabIndex","addDomEvent","getActiveElement","raf","getEventTarget","isDocument","hasControllerElements","isControlledByExpandedController","isFocusable","__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","activeFocusTraps","activateTrap","trapStack","trap","length","activeTrap","pause","trapIndex","indexOf","push","splice","deactivateTrap","unpause","sharedTrapStack","FocusTrap","constructor","elements","options","containers","containerGroups","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","delayInitialFocusTimer","recentNavEvent","Set","event","target","targetContained","findContainerIndex","state","stopImmediatePropagation","nextNode","navAcrossContainers","mruContainerIdx","tabbableNodes","mruTabIdx","findIndex","node","config","isKeyForward","some","g","n","findNextNavNode","isBackward","isKeyBackward","tryFocus","getInitialFocusNode","valueOrHandler","clickOutsideDeactivates","deactivate","returnFocus","returnFocusOnDeactivate","allowOutsideClick","preventDefault","destinationNode","isTabEvent","isEscapeEvent","escapeDeactivates","win","doc","defaultView","window","_mutationObserver","MutationObserver","mutations","isFocusedNodeRemoved","mutation","removedNodes","Array","from","hasControlledChanges","type","attributeName","addedNodes","nodeType","Node","ELEMENT_NODE","element","id","c","contains","updateTabbableNodes","updatePortalContainers","disconnect","map","container","observe","subtree","childList","attributes","attributeFilter","portalContainers","forEach","portalContainer","observePortalContainer","getNodeForOption","hasFallback","activeElement","firstTabbableGroup","firstTabbableNode","Error","isConnected","focus","preventScroll","isSelectableInput","select","deactivateOptions","onDeactivate","onPostDeactivate","checkCanReturnFocus","clearTimeout","removeListeners","updateObservedNodes","clear","getOption","finishDeactivation","delay","returnFocusNode","getReturnFocusNode","then","pauseOptions","onPause","onPostPause","unpauseOptions","onUnpause","onPostUnpause","addListeners","containerElements","isArray","filter","Boolean","previousActiveElement","params","configOverrideOptions","optionName","configOptionName","optionValue","querySelector","err","message","opts","containerIndex","containerGroup","lastTabbableNode","startOfGroupIndex","nextTabbableNode","destinationGroupIndex","destinationGroup","lastDomTabbableNode","lastOfGroupIndex","firstDomTabbableNode","delayInitialFocus","followControlledElements","e","shiftKey","document","updateContainerElements","setupMutationObserver","addPortalContainer","controlledElement","parentElement","has","add","controlledElements","composedPath","includes","find","focusableNodes","slice","reverse","posTabIndexesFound","forward","nodeIdx","el","group","listenerCleanups","handleFocus","handlePointerDown","capture","passive","handleClick","handleTabKey","handleEscapeKey","cleanup","activate","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","concat","isComposing","fn","setTimeout","localName","trapFocus","contentEl","fallbackFocus","destroy"],"sources":["/Users/ameliamagick/personal-finance-tracker/node_modules/@zag-js/focus-trap/dist/index.mjs"],"sourcesContent":["import { getDocument, getControlledElements, isControlledElement, getTabbables, getFocusables, isTabbable, getTabIndex, addDomEvent, getActiveElement, raf, getEventTarget, isDocument, hasControllerElements, isControlledByExpandedController, isFocusable } from '@zag-js/dom-query';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar activeFocusTraps = {\n  activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      const activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap(trapStack, trap) {\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar sharedTrapStack = [];\nvar FocusTrap = class {\n  constructor(elements, options) {\n    __publicField(this, \"trapStack\");\n    __publicField(this, \"config\");\n    __publicField(this, \"doc\");\n    __publicField(this, \"state\", {\n      containers: [],\n      containerGroups: [],\n      tabbableGroups: [],\n      nodeFocusedBeforeActivation: null,\n      mostRecentlyFocusedNode: null,\n      active: false,\n      paused: false,\n      delayInitialFocusTimer: void 0,\n      recentNavEvent: void 0\n    });\n    // Track portal containers that contain controlled elements\n    __publicField(this, \"portalContainers\", /* @__PURE__ */ new Set());\n    __publicField(this, \"listenerCleanups\", []);\n    __publicField(this, \"handleFocus\", (event) => {\n      const target = getEventTarget(event);\n      const targetContained = this.findContainerIndex(target, event) >= 0;\n      if (targetContained || isDocument(target)) {\n        if (targetContained) {\n          this.state.mostRecentlyFocusedNode = target;\n        }\n      } else {\n        event.stopImmediatePropagation();\n        let nextNode;\n        let navAcrossContainers = true;\n        if (this.state.mostRecentlyFocusedNode) {\n          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {\n            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);\n            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];\n            if (tabbableNodes.length > 0) {\n              const mruTabIdx = tabbableNodes.findIndex((node) => node === this.state.mostRecentlyFocusedNode);\n              if (mruTabIdx >= 0) {\n                if (this.config.isKeyForward(this.state.recentNavEvent)) {\n                  if (mruTabIdx + 1 < tabbableNodes.length) {\n                    nextNode = tabbableNodes[mruTabIdx + 1];\n                    navAcrossContainers = false;\n                  }\n                } else {\n                  if (mruTabIdx - 1 >= 0) {\n                    nextNode = tabbableNodes[mruTabIdx - 1];\n                    navAcrossContainers = false;\n                  }\n                }\n              }\n            }\n          } else {\n            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => getTabIndex(n) > 0))) {\n              navAcrossContainers = false;\n            }\n          }\n        } else {\n          navAcrossContainers = false;\n        }\n        if (navAcrossContainers) {\n          nextNode = this.findNextNavNode({\n            // move FROM the MRU node, not event-related node (which will be the node that is\n            //  outside the trap causing the focus escape we're trying to fix)\n            target: this.state.mostRecentlyFocusedNode,\n            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)\n          });\n        }\n        if (nextNode) {\n          this.tryFocus(nextNode);\n        } else {\n          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());\n        }\n      }\n      this.state.recentNavEvent = void 0;\n    });\n    __publicField(this, \"handlePointerDown\", (event) => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n    });\n    __publicField(this, \"handleClick\", (event) => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n    __publicField(this, \"handleTabKey\", (event) => {\n      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {\n        this.state.recentNavEvent = event;\n        const isBackward = this.config.isKeyBackward(event);\n        const destinationNode = this.findNextNavNode({ event, isBackward });\n        if (!destinationNode) return;\n        if (isTabEvent(event)) {\n          event.preventDefault();\n        }\n        this.tryFocus(destinationNode);\n      }\n    });\n    __publicField(this, \"handleEscapeKey\", (event) => {\n      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {\n        event.preventDefault();\n        this.deactivate();\n      }\n    });\n    __publicField(this, \"_mutationObserver\");\n    __publicField(this, \"setupMutationObserver\", () => {\n      const win = this.doc.defaultView || window;\n      this._mutationObserver = new win.MutationObserver((mutations) => {\n        const isFocusedNodeRemoved = mutations.some((mutation) => {\n          const removedNodes = Array.from(mutation.removedNodes);\n          return removedNodes.some((node) => node === this.state.mostRecentlyFocusedNode);\n        });\n        if (isFocusedNodeRemoved) {\n          this.tryFocus(this.getInitialFocusNode());\n        }\n        const hasControlledChanges = mutations.some((mutation) => {\n          if (mutation.type === \"attributes\" && (mutation.attributeName === \"aria-controls\" || mutation.attributeName === \"aria-expanded\")) {\n            return true;\n          }\n          if (mutation.type === \"childList\" && mutation.addedNodes.length > 0) {\n            return Array.from(mutation.addedNodes).some((node) => {\n              if (node.nodeType !== Node.ELEMENT_NODE) return false;\n              const element = node;\n              if (hasControllerElements(element)) {\n                return true;\n              }\n              if (element.id && !this.state.containers.some((c) => c.contains(element))) {\n                return isControlledByExpandedController(element);\n              }\n              return false;\n            });\n          }\n          return false;\n        });\n        if (hasControlledChanges && this.state.active && !this.state.paused) {\n          this.updateTabbableNodes();\n          this.updatePortalContainers();\n        }\n      });\n    });\n    __publicField(this, \"updateObservedNodes\", () => {\n      this._mutationObserver?.disconnect();\n      if (this.state.active && !this.state.paused) {\n        this.state.containers.map((container) => {\n          this._mutationObserver?.observe(container, {\n            subtree: true,\n            childList: true,\n            attributes: true,\n            attributeFilter: [\"aria-controls\", \"aria-expanded\"]\n          });\n        });\n        this.portalContainers.forEach((portalContainer) => {\n          this.observePortalContainer(portalContainer);\n        });\n      }\n    });\n    __publicField(this, \"getInitialFocusNode\", () => {\n      let node = this.getNodeForOption(\"initialFocus\", { hasFallback: true });\n      if (node === false) {\n        return false;\n      }\n      if (node === void 0 || node && !isFocusable(node)) {\n        const activeElement = getActiveElement(this.doc);\n        if (activeElement && this.findContainerIndex(activeElement) >= 0) {\n          node = activeElement;\n        } else {\n          const firstTabbableGroup = this.state.tabbableGroups[0];\n          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n          node = firstTabbableNode || this.getNodeForOption(\"fallbackFocus\");\n        }\n      } else if (node === null) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      if (!node) {\n        throw new Error(\"Your focus-trap needs to have at least one focusable element\");\n      }\n      if (!node.isConnected) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return node;\n    });\n    __publicField(this, \"tryFocus\", (node) => {\n      if (node === false) return;\n      if (node === getActiveElement(this.doc)) return;\n      if (!node || !node.focus) {\n        this.tryFocus(this.getInitialFocusNode());\n        return;\n      }\n      node.focus({ preventScroll: !!this.config.preventScroll });\n      this.state.mostRecentlyFocusedNode = node;\n      if (isSelectableInput(node)) {\n        node.select();\n      }\n    });\n    __publicField(this, \"deactivate\", (deactivateOptions) => {\n      if (!this.state.active) return this;\n      const options = {\n        onDeactivate: this.config.onDeactivate,\n        onPostDeactivate: this.config.onPostDeactivate,\n        checkCanReturnFocus: this.config.checkCanReturnFocus,\n        ...deactivateOptions\n      };\n      clearTimeout(this.state.delayInitialFocusTimer);\n      this.state.delayInitialFocusTimer = void 0;\n      this.removeListeners();\n      this.state.active = false;\n      this.state.paused = false;\n      this.updateObservedNodes();\n      activeFocusTraps.deactivateTrap(this.trapStack, this);\n      this.portalContainers.clear();\n      const onDeactivate = this.getOption(options, \"onDeactivate\");\n      const onPostDeactivate = this.getOption(options, \"onPostDeactivate\");\n      const checkCanReturnFocus = this.getOption(options, \"checkCanReturnFocus\");\n      const returnFocus = this.getOption(options, \"returnFocus\", \"returnFocusOnDeactivate\");\n      onDeactivate?.();\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n            this.tryFocus(returnFocusNode);\n          }\n          onPostDeactivate?.();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    });\n    __publicField(this, \"pause\", (pauseOptions) => {\n      if (this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onPause = this.getOption(pauseOptions, \"onPause\");\n      const onPostPause = this.getOption(pauseOptions, \"onPostPause\");\n      this.state.paused = true;\n      onPause?.();\n      this.removeListeners();\n      this.updateObservedNodes();\n      onPostPause?.();\n      return this;\n    });\n    __publicField(this, \"unpause\", (unpauseOptions) => {\n      if (!this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onUnpause = this.getOption(unpauseOptions, \"onUnpause\");\n      const onPostUnpause = this.getOption(unpauseOptions, \"onPostUnpause\");\n      this.state.paused = false;\n      onUnpause?.();\n      this.updateTabbableNodes();\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostUnpause?.();\n      return this;\n    });\n    __publicField(this, \"updateContainerElements\", (containerElements) => {\n      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);\n      if (this.state.active) {\n        this.updateTabbableNodes();\n      }\n      this.updateObservedNodes();\n      return this;\n    });\n    __publicField(this, \"getReturnFocusNode\", (previousActiveElement) => {\n      const node = this.getNodeForOption(\"setReturnFocus\", {\n        params: [previousActiveElement]\n      });\n      return node ? node : node === false ? false : previousActiveElement;\n    });\n    __publicField(this, \"getOption\", (configOverrideOptions, optionName, configOptionName) => {\n      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (\n        // @ts-expect-error\n        this.config[configOptionName || optionName]\n      );\n    });\n    __publicField(this, \"getNodeForOption\", (optionName, { hasFallback = false, params = [] } = {}) => {\n      let optionValue = this.config[optionName];\n      if (typeof optionValue === \"function\") optionValue = optionValue(...params);\n      if (optionValue === true) optionValue = void 0;\n      if (!optionValue) {\n        if (optionValue === void 0 || optionValue === false) {\n          return optionValue;\n        }\n        throw new Error(`\\`${optionName}\\` was specified but was not a node, or did not return a node`);\n      }\n      let node = optionValue;\n      if (typeof optionValue === \"string\") {\n        try {\n          node = this.doc.querySelector(optionValue);\n        } catch (err) {\n          throw new Error(`\\`${optionName}\\` appears to be an invalid selector; error=\"${err.message}\"`);\n        }\n        if (!node) {\n          if (!hasFallback) {\n            throw new Error(`\\`${optionName}\\` as selector refers to no known node`);\n          }\n        }\n      }\n      return node;\n    });\n    __publicField(this, \"findNextNavNode\", (opts) => {\n      const { event, isBackward = false } = opts;\n      const target = opts.target || getEventTarget(event);\n      this.updateTabbableNodes();\n      let destinationNode = null;\n      if (this.state.tabbableGroups.length > 0) {\n        const containerIndex = this.findContainerIndex(target, event);\n        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;\n        if (containerIndex < 0) {\n          if (isBackward) {\n            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;\n          } else {\n            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;\n          }\n        } else if (isBackward) {\n          let startOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ firstTabbableNode }) => target === firstTabbableNode\n          );\n          if (startOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target, false))) {\n            startOfGroupIndex = containerIndex;\n          }\n          if (startOfGroupIndex >= 0) {\n            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target, false);\n          }\n        } else {\n          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ lastTabbableNode }) => target === lastTabbableNode\n          );\n          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target))) {\n            lastOfGroupIndex = containerIndex;\n          }\n          if (lastOfGroupIndex >= 0) {\n            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target);\n          }\n        }\n      } else {\n        destinationNode = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return destinationNode;\n    });\n    this.trapStack = options.trapStack || sharedTrapStack;\n    const config = {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true,\n      delayInitialFocus: true,\n      followControlledElements: true,\n      isKeyForward(e) {\n        return isTabEvent(e) && !e.shiftKey;\n      },\n      isKeyBackward(e) {\n        return isTabEvent(e) && e.shiftKey;\n      },\n      ...options\n    };\n    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);\n    this.config = config;\n    this.updateContainerElements(elements);\n    this.setupMutationObserver();\n  }\n  addPortalContainer(controlledElement) {\n    const portalContainer = controlledElement.parentElement;\n    if (portalContainer && !this.portalContainers.has(portalContainer)) {\n      this.portalContainers.add(portalContainer);\n      if (this.state.active && !this.state.paused) {\n        this.observePortalContainer(portalContainer);\n      }\n    }\n  }\n  observePortalContainer(portalContainer) {\n    this._mutationObserver?.observe(portalContainer, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"aria-controls\", \"aria-expanded\"]\n    });\n  }\n  updatePortalContainers() {\n    if (!this.config.followControlledElements) return;\n    this.state.containers.forEach((container) => {\n      const controlledElements = getControlledElements(container);\n      controlledElements.forEach((controlledElement) => {\n        this.addPortalContainer(controlledElement);\n      });\n    });\n  }\n  get active() {\n    return this.state.active;\n  }\n  get paused() {\n    return this.state.paused;\n  }\n  findContainerIndex(element, event) {\n    const composedPath = typeof event?.composedPath === \"function\" ? event.composedPath() : void 0;\n    return this.state.containerGroups.findIndex(\n      ({ container, tabbableNodes }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find((node) => node === element) || this.isControlledElement(container, element)\n    );\n  }\n  isControlledElement(container, element) {\n    if (!this.config.followControlledElements) return false;\n    return isControlledElement(container, element);\n  }\n  updateTabbableNodes() {\n    this.state.containerGroups = this.state.containers.map((container) => {\n      const tabbableNodes = getTabbables(container);\n      const focusableNodes = getFocusables(container);\n      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;\n      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;\n      const firstDomTabbableNode = focusableNodes.find((node) => isTabbable(node));\n      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node) => isTabbable(node));\n      const posTabIndexesFound = !!tabbableNodes.find((node) => getTabIndex(node) > 0);\n      function nextTabbableNode(node, forward = true) {\n        const nodeIdx = tabbableNodes.indexOf(node);\n        if (nodeIdx < 0) {\n          if (forward) {\n            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find((el) => isTabbable(el));\n          }\n          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find((el) => isTabbable(el));\n        }\n        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n      }\n      return {\n        container,\n        tabbableNodes,\n        focusableNodes,\n        posTabIndexesFound,\n        firstTabbableNode,\n        lastTabbableNode,\n        firstDomTabbableNode,\n        lastDomTabbableNode,\n        nextTabbableNode\n      };\n    });\n    this.state.tabbableGroups = this.state.containerGroups.filter((group) => group.tabbableNodes.length > 0);\n    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption(\"fallbackFocus\")) {\n      throw new Error(\n        \"Your focus-trap must have at least one container with at least one tabbable node in it at all times\"\n      );\n    }\n    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {\n      throw new Error(\n        \"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\"\n      );\n    }\n  }\n  addListeners() {\n    if (!this.state.active) return;\n    activeFocusTraps.activateTrap(this.trapStack, this);\n    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {\n      this.tryFocus(this.getInitialFocusNode());\n    }) : this.tryFocus(this.getInitialFocusNode());\n    this.listenerCleanups.push(\n      addDomEvent(this.doc, \"focusin\", this.handleFocus, true),\n      addDomEvent(this.doc, \"mousedown\", this.handlePointerDown, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"touchstart\", this.handlePointerDown, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"click\", this.handleClick, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"keydown\", this.handleTabKey, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"keydown\", this.handleEscapeKey)\n    );\n    return this;\n  }\n  removeListeners() {\n    if (!this.state.active) return;\n    this.listenerCleanups.forEach((cleanup) => cleanup());\n    this.listenerCleanups = [];\n    return this;\n  }\n  activate(activateOptions) {\n    if (this.state.active) {\n      return this;\n    }\n    const onActivate = this.getOption(activateOptions, \"onActivate\");\n    const onPostActivate = this.getOption(activateOptions, \"onPostActivate\");\n    const checkCanFocusTrap = this.getOption(activateOptions, \"checkCanFocusTrap\");\n    if (!checkCanFocusTrap) {\n      this.updateTabbableNodes();\n    }\n    this.state.active = true;\n    this.state.paused = false;\n    this.state.nodeFocusedBeforeActivation = getActiveElement(this.doc);\n    onActivate?.();\n    const finishActivation = () => {\n      if (checkCanFocusTrap) {\n        this.updateTabbableNodes();\n      }\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostActivate?.();\n    };\n    if (checkCanFocusTrap) {\n      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);\n      return this;\n    }\n    finishActivation();\n    return this;\n  }\n};\nvar isTabEvent = (event) => event.key === \"Tab\";\nvar valueOrHandler = (value, ...params) => typeof value === \"function\" ? value(...params) : value;\nvar isEscapeEvent = (event) => !event.isComposing && event.key === \"Escape\";\nvar delay = (fn) => setTimeout(fn, 0);\nvar isSelectableInput = (node) => node.localName === \"input\" && \"select\" in node && typeof node.select === \"function\";\n\n// src/index.ts\nfunction trapFocus(el, options = {}) {\n  let trap;\n  const cleanup = raf(() => {\n    const contentEl = typeof el === \"function\" ? el() : el;\n    if (!contentEl) return;\n    trap = new FocusTrap(contentEl, {\n      escapeDeactivates: false,\n      allowOutsideClick: true,\n      preventScroll: true,\n      returnFocusOnDeactivate: true,\n      delayInitialFocus: false,\n      fallbackFocus: contentEl,\n      ...options,\n      document: getDocument(contentEl)\n    });\n    try {\n      trap.activate();\n    } catch {\n    }\n  });\n  return function destroy() {\n    trap?.deactivate();\n    cleanup();\n  };\n}\n\nexport { FocusTrap, trapFocus };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}