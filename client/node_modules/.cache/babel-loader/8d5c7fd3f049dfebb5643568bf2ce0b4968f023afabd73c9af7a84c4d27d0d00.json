{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { raf, addDomEvent, getEventTarget, getEventPoint, isLeftClick } from '@zag-js/dom-query';\nimport { createSplitProps, toPx } from '@zag-js/utils';\nimport { ariaHidden } from '@zag-js/aria-hidden';\nimport { createMachine } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { trapFocus } from '@zag-js/focus-trap';\nimport { preventBodyScroll } from '@zag-js/remove-scroll';\nimport { createProps } from '@zag-js/types';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar anatomy = createAnatomy(\"bottom-sheet\").parts(\"content\", \"title\", \"trigger\", \"backdrop\", \"grabber\", \"grabberIndicator\", \"closeTrigger\");\nvar parts = anatomy.build();\nvar getContentId = ctx => ctx.ids?.content ?? `bottom-sheet:${ctx.id}:content`;\nvar getTitleId = ctx => ctx.ids?.title ?? `bottom-sheet:${ctx.id}:title`;\nvar getTriggerId = ctx => ctx.ids?.trigger ?? `bottom-sheet:${ctx.id}:trigger`;\nvar getBackdropId = ctx => ctx.ids?.backdrop ?? `bottom-sheet:${ctx.id}:backdrop`;\nvar getGrabberId = ctx => ctx.ids?.grabber ?? `bottom-sheet:${ctx.id}:grabber`;\nvar getGrabberIndicatorId = ctx => ctx.ids?.grabberIndicator ?? `bottom-sheet:${ctx.id}:grabber-indicator`;\nvar getCloseTriggerId = ctx => ctx.ids?.closeTrigger ?? `bottom-sheet:${ctx.id}:close-trigger`;\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getTriggerEl = ctx => ctx.getById(getTriggerId(ctx));\nvar getCloseTriggerEl = ctx => ctx.getById(getCloseTriggerId(ctx));\n\n// src/bottom-sheet.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    context,\n    scope,\n    prop\n  } = service;\n  const open = state.hasTag(\"open\");\n  const dragOffset = context.get(\"dragOffset\");\n  const dragging = dragOffset !== null;\n  const activeSnapPoint = context.get(\"activeSnapPoint\");\n  const resolvedActiveSnapPoint = context.get(\"resolvedActiveSnapPoint\");\n  const translate = dragOffset ?? resolvedActiveSnapPoint?.offset;\n  function onPointerDown(event) {\n    if (!isLeftClick(event)) return;\n    const target = getEventTarget(event);\n    if (target?.hasAttribute(\"data-no-drag\") || target?.closest(\"[data-no-drag]\")) return;\n    if (state.matches(\"closing\")) return;\n    send({\n      type: \"POINTER_DOWN\",\n      point: getEventPoint(event)\n    });\n  }\n  return {\n    open,\n    dragging,\n    setOpen(nextOpen) {\n      const open2 = state.hasTag(\"open\");\n      if (open2 === nextOpen) return;\n      send({\n        type: nextOpen ? \"OPEN\" : \"CLOSE\"\n      });\n    },\n    snapPoints: prop(\"snapPoints\"),\n    activeSnapPoint,\n    setActiveSnapPoint(snapPoint) {\n      const activeSnapPoint2 = context.get(\"activeSnapPoint\");\n      if (activeSnapPoint2 === snapPoint) return;\n      send({\n        type: \"ACTIVE_SNAP_POINT.SET\",\n        snapPoint\n      });\n    },\n    getOpenPercentage() {\n      if (!open) return 0;\n      const contentHeight = context.get(\"contentHeight\");\n      if (!contentHeight) return 0;\n      const currentOffset = translate ?? 0;\n      return Math.max(0, Math.min(1, 1 - currentOffset / contentHeight));\n    },\n    getActiveSnapIndex() {\n      const snapPoints = prop(\"snapPoints\");\n      return snapPoints.indexOf(activeSnapPoint);\n    },\n    getContentHeight() {\n      return context.get(\"contentHeight\");\n    },\n    getContentProps(props2 = {\n      draggable: true\n    }) {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: prop(\"dir\"),\n        id: getContentId(scope),\n        tabIndex: -1,\n        role: \"dialog\",\n        \"aria-modal\": prop(\"modal\"),\n        \"aria-labelledby\": getTitleId(scope),\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        style: {\n          transform: \"translate3d(0, var(--bottom-sheet-translate, 0), 0)\",\n          transitionDuration: dragging ? \"0s\" : void 0,\n          \"--bottom-sheet-translate\": toPx(translate),\n          willChange: \"transform\"\n        },\n        onPointerDown(event) {\n          if (!props2.draggable) return;\n          onPointerDown(event);\n        }\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: getTitleId(scope),\n        dir: prop(\"dir\")\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: getTriggerId(scope),\n        type: \"button\",\n        onClick() {\n          send({\n            type: open ? \"CLOSE\" : \"OPEN\"\n          });\n        }\n      });\n    },\n    getBackdropProps() {\n      return normalize.element({\n        ...parts.backdrop.attrs,\n        id: getBackdropId(scope),\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        style: {\n          willChange: \"opacity\"\n        }\n      });\n    },\n    getGrabberProps() {\n      return normalize.element({\n        ...parts.grabber.attrs,\n        id: getGrabberId(scope),\n        onPointerDown(event) {\n          onPointerDown(event);\n        },\n        style: {\n          touchAction: \"none\"\n        }\n      });\n    },\n    getGrabberIndicatorProps() {\n      return normalize.element({\n        ...parts.grabberIndicator.attrs,\n        id: getGrabberIndicatorId(scope)\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.button({\n        ...parts.closeTrigger.attrs,\n        id: getCloseTriggerId(scope),\n        onClick() {\n          send({\n            type: \"CLOSE\"\n          });\n        }\n      });\n    }\n  };\n}\n\n// src/utils/find-closest-snap-point.ts\nfunction findClosestSnapPoint(offset, snapPoints) {\n  return snapPoints.reduce((acc, curr) => {\n    const closestDiff = Math.abs(offset - acc.offset);\n    const currentDiff = Math.abs(offset - curr.offset);\n    return currentDiff < closestDiff ? curr : acc;\n  });\n}\n\n// src/utils/get-scroll-info.ts\nfunction isScrollContainer(element) {\n  const styles = getComputedStyle(element);\n  const overflow = styles.overflowY;\n  return overflow === \"auto\" || overflow === \"scroll\";\n}\nfunction getScrollInfo(target, container) {\n  let element = target;\n  let availableScroll = 0;\n  let availableScrollTop = 0;\n  while (element) {\n    const {\n      clientHeight,\n      scrollTop,\n      scrollHeight\n    } = element;\n    const scrolled = scrollHeight - scrollTop - clientHeight;\n    if ((scrollTop !== 0 || scrolled !== 0) && isScrollContainer(element)) {\n      availableScroll += scrolled;\n      availableScrollTop += scrollTop;\n    }\n    if (element === container || element === document.documentElement) break;\n    element = element.parentNode;\n  }\n  return {\n    availableScroll,\n    availableScrollTop\n  };\n}\n\n// src/utils/drag-manager.ts\nvar DRAG_START_THRESHOLD = 0.3;\nvar DragManager = class {\n  constructor() {\n    __publicField(this, \"pointerStart\", null);\n    __publicField(this, \"dragOffset\", null);\n    __publicField(this, \"lastPoint\", null);\n    __publicField(this, \"lastTimestamp\", null);\n    __publicField(this, \"velocity\", null);\n  }\n  setPointerStart(point) {\n    this.pointerStart = point;\n  }\n  clearPointerStart() {\n    this.pointerStart = null;\n  }\n  getPointerStart() {\n    return this.pointerStart;\n  }\n  setDragOffset(point, resolvedActiveSnapPointOffset) {\n    if (!this.pointerStart) return;\n    const currentTimestamp = (/* @__PURE__ */new Date()).getTime();\n    if (this.lastPoint) {\n      const dy = point.y - this.lastPoint.y;\n      if (this.lastTimestamp) {\n        const dt = currentTimestamp - this.lastTimestamp;\n        if (dt > 0) {\n          const calculatedVelocity = dy / dt * 1e3;\n          this.velocity = Number.isFinite(calculatedVelocity) ? calculatedVelocity : 0;\n        }\n      }\n    }\n    this.lastPoint = point;\n    this.lastTimestamp = currentTimestamp;\n    let delta = this.pointerStart.y - point.y - resolvedActiveSnapPointOffset;\n    if (delta > 0) delta = 0;\n    this.dragOffset = -delta;\n  }\n  getDragOffset() {\n    return this.dragOffset;\n  }\n  clearDragOffset() {\n    this.dragOffset = null;\n  }\n  getVelocity() {\n    return this.velocity;\n  }\n  clearVelocityTracking() {\n    this.lastPoint = null;\n    this.lastTimestamp = null;\n    this.velocity = null;\n  }\n  clear() {\n    this.clearPointerStart();\n    this.clearDragOffset();\n    this.clearVelocityTracking();\n  }\n  shouldStartDragging(point, target, container, preventDragOnScroll) {\n    if (!this.pointerStart || !container) return false;\n    if (preventDragOnScroll) {\n      const delta = this.pointerStart.y - point.y;\n      if (Math.abs(delta) < DRAG_START_THRESHOLD) return false;\n      const {\n        availableScroll,\n        availableScrollTop\n      } = getScrollInfo(target, container);\n      if (delta > 0 && Math.abs(availableScroll) > 1 || delta < 0 && Math.abs(availableScrollTop) > 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  findClosestSnapPoint(snapPoints) {\n    if (this.dragOffset === null) {\n      return snapPoints[0]?.value ?? 1;\n    }\n    const closest = findClosestSnapPoint(this.dragOffset, snapPoints);\n    return closest.value;\n  }\n  shouldDismiss(contentHeight, snapPoints, swipeVelocityThreshold, closeThreshold) {\n    if (this.dragOffset === null || this.velocity === null || contentHeight === null) return false;\n    const visibleHeight = contentHeight - this.dragOffset;\n    const smallestSnapPoint = snapPoints.reduce((acc, curr) => curr.offset > acc.offset ? curr : acc);\n    const isFastSwipe = this.velocity > 0 && this.velocity >= swipeVelocityThreshold;\n    const closeThresholdInPixels = contentHeight * (1 - closeThreshold);\n    const isBelowSmallestSnapPoint = visibleHeight < contentHeight - smallestSnapPoint.offset;\n    const isBelowCloseThreshold = visibleHeight < closeThresholdInPixels;\n    const hasEnoughDragToDismiss = isBelowCloseThreshold && isBelowSmallestSnapPoint || visibleHeight === 0;\n    return isFastSwipe || hasEnoughDragToDismiss;\n  }\n};\n\n// src/utils/resolve-snap-point.ts\nfunction resolveSnapPoint(snapPoint, containerHeight) {\n  if (typeof snapPoint === \"number\") {\n    return {\n      value: snapPoint,\n      offset: containerHeight - snapPoint * containerHeight\n    };\n  }\n  if (typeof snapPoint === \"string\") {\n    return {\n      value: snapPoint,\n      offset: containerHeight - parseFloat(snapPoint)\n    };\n  }\n  throw new Error(`Invalid snap point: ${snapPoint}`);\n}\n\n// src/bottom-sheet.machine.ts\nvar machine = createMachine({\n  props({\n    props: props2,\n    scope\n  }) {\n    const alertDialog = props2.role === \"alertdialog\";\n    const initialFocusEl = alertDialog ? () => getCloseTriggerEl(scope) : void 0;\n    const modal = typeof props2.modal === \"boolean\" ? props2.modal : true;\n    return {\n      modal,\n      trapFocus: modal,\n      preventScroll: modal,\n      closeOnInteractOutside: true,\n      closeOnEscape: true,\n      restoreFocus: true,\n      initialFocusEl,\n      snapPoints: [1],\n      defaultActiveSnapPoint: 1,\n      swipeVelocityThreshold: 700,\n      closeThreshold: 0.25,\n      preventDragOnScroll: true,\n      ...props2\n    };\n  },\n  context({\n    bindable,\n    prop\n  }) {\n    return {\n      dragOffset: bindable(() => ({\n        defaultValue: null\n      })),\n      activeSnapPoint: bindable(() => ({\n        defaultValue: prop(\"defaultActiveSnapPoint\"),\n        value: prop(\"activeSnapPoint\"),\n        onChange(value) {\n          return prop(\"onActiveSnapPointChange\")?.({\n            snapPoint: value\n          });\n        }\n      })),\n      resolvedActiveSnapPoint: bindable(() => ({\n        defaultValue: null\n      })),\n      contentHeight: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  refs() {\n    return {\n      dragManager: new DragManager()\n    };\n  },\n  computed: {\n    resolvedSnapPoints({\n      context,\n      prop\n    }) {\n      const contentHeight = context.get(\"contentHeight\");\n      if (contentHeight === null) return [];\n      return prop(\"snapPoints\").map(snapPoint => resolveSnapPoint(snapPoint, contentHeight));\n    }\n  },\n  watch({\n    track,\n    context,\n    prop,\n    action\n  }) {\n    track([() => context.get(\"activeSnapPoint\"), () => context.get(\"contentHeight\")], () => {\n      const activeSnapPoint = context.get(\"activeSnapPoint\");\n      const contentHeight = context.get(\"contentHeight\");\n      if (contentHeight === null) return;\n      const resolvedActiveSnapPoint = resolveSnapPoint(activeSnapPoint, contentHeight);\n      context.set(\"resolvedActiveSnapPoint\", resolvedActiveSnapPoint);\n    });\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n  },\n  initialState({\n    prop\n  }) {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"closed\";\n  },\n  on: {\n    \"ACTIVE_SNAP_POINT.SET\": {\n      actions: [\"setActiveSnapPoint\"]\n    }\n  },\n  states: {\n    open: {\n      tags: [\"open\"],\n      effects: [\"trackDismissableElement\", \"preventScroll\", \"trapFocus\", \"hideContentBelow\", \"trackPointerMove\", \"trackContentHeight\"],\n      on: {\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\"\n        },\n        POINTER_DOWN: {\n          actions: [\"setPointerStart\"]\n        },\n        POINTER_MOVE: [{\n          guard: \"isDragging\",\n          actions: [\"setDragOffset\"]\n        }, {\n          guard: \"shouldStartDragging\",\n          actions: [\"setDragOffset\"]\n        }],\n        POINTER_UP: [{\n          guard: \"shouldCloseOnSwipe\",\n          target: \"closing\"\n        }, {\n          guard: \"isDragging\",\n          actions: [\"setClosestSnapPoint\", \"clearPointerStart\", \"clearDragOffset\"]\n        }, {\n          actions: [\"clearPointerStart\", \"clearDragOffset\"]\n        }],\n        CLOSE: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closing\",\n          actions: [\"invokeOnClose\"]\n        }]\n      }\n    },\n    closing: {\n      effects: [\"trackExitAnimation\"],\n      on: {\n        ANIMATION_END: {\n          target: \"closed\",\n          actions: [\"invokeOnClose\", \"clearPointerStart\", \"clearDragOffset\", \"clearActiveSnapPoint\", \"clearResolvedActiveSnapPoint\", \"clearContentHeight\", \"clearVelocityTracking\"]\n        }\n      }\n    },\n    closed: {\n      tags: [\"closed\"],\n      on: {\n        \"CONTROLLED.OPEN\": {\n          target: \"open\"\n        },\n        OPEN: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }]\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isOpenControlled: ({\n        prop\n      }) => prop(\"open\") !== void 0,\n      isDragging({\n        context\n      }) {\n        return context.get(\"dragOffset\") !== null;\n      },\n      shouldStartDragging({\n        prop,\n        refs,\n        event,\n        scope\n      }) {\n        const dragManager = refs.get(\"dragManager\");\n        return dragManager.shouldStartDragging(event.point, event.target, getContentEl(scope), prop(\"preventDragOnScroll\"));\n      },\n      shouldCloseOnSwipe({\n        prop,\n        context,\n        computed,\n        refs\n      }) {\n        const dragManager = refs.get(\"dragManager\");\n        return dragManager.shouldDismiss(context.get(\"contentHeight\"), computed(\"resolvedSnapPoints\"), prop(\"swipeVelocityThreshold\"), prop(\"closeThreshold\"));\n      }\n    },\n    actions: {\n      invokeOnOpen({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: true\n        });\n      },\n      invokeOnClose({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: false\n        });\n      },\n      setActiveSnapPoint({\n        context,\n        event\n      }) {\n        context.set(\"activeSnapPoint\", event.snapPoint);\n      },\n      setPointerStart({\n        event,\n        refs\n      }) {\n        refs.get(\"dragManager\").setPointerStart(event.point);\n      },\n      setDragOffset({\n        context,\n        event,\n        refs\n      }) {\n        const dragManager = refs.get(\"dragManager\");\n        dragManager.setDragOffset(event.point, context.get(\"resolvedActiveSnapPoint\")?.offset || 0);\n        context.set(\"dragOffset\", dragManager.getDragOffset());\n      },\n      setClosestSnapPoint({\n        computed,\n        context,\n        refs\n      }) {\n        const snapPoints = computed(\"resolvedSnapPoints\");\n        const contentHeight = context.get(\"contentHeight\");\n        if (!snapPoints.length || contentHeight === null) return;\n        const dragManager = refs.get(\"dragManager\");\n        const closestSnapPoint = dragManager.findClosestSnapPoint(snapPoints);\n        context.set(\"activeSnapPoint\", closestSnapPoint);\n        const resolved = resolveSnapPoint(closestSnapPoint, contentHeight);\n        context.set(\"resolvedActiveSnapPoint\", resolved);\n      },\n      clearDragOffset({\n        context,\n        refs\n      }) {\n        refs.get(\"dragManager\").clearDragOffset();\n        context.set(\"dragOffset\", null);\n      },\n      clearActiveSnapPoint({\n        context,\n        prop\n      }) {\n        context.set(\"activeSnapPoint\", prop(\"defaultActiveSnapPoint\"));\n      },\n      clearResolvedActiveSnapPoint({\n        context\n      }) {\n        context.set(\"resolvedActiveSnapPoint\", null);\n      },\n      clearPointerStart({\n        refs\n      }) {\n        refs.get(\"dragManager\").clearPointerStart();\n      },\n      clearContentHeight({\n        context\n      }) {\n        context.set(\"contentHeight\", null);\n      },\n      clearVelocityTracking({\n        refs\n      }) {\n        refs.get(\"dragManager\").clearVelocityTracking();\n      },\n      toggleVisibility({\n        event,\n        send,\n        prop\n      }) {\n        send({\n          type: prop(\"open\") ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: event\n        });\n      }\n    },\n    effects: {\n      trackDismissableElement({\n        scope,\n        prop,\n        send\n      }) {\n        const getContentEl2 = () => getContentEl(scope);\n        return trackDismissableElement(getContentEl2, {\n          defer: true,\n          exclude: [getTriggerEl(scope)],\n          onInteractOutside(event) {\n            prop(\"onInteractOutside\")?.(event);\n            if (!prop(\"closeOnInteractOutside\")) {\n              event.preventDefault();\n            }\n          },\n          onFocusOutside: prop(\"onFocusOutside\"),\n          onEscapeKeyDown(event) {\n            prop(\"onEscapeKeyDown\")?.(event);\n            if (!prop(\"closeOnEscape\")) {\n              event.preventDefault();\n            }\n          },\n          onPointerDownOutside: prop(\"onPointerDownOutside\"),\n          onRequestDismiss: prop(\"onRequestDismiss\"),\n          onDismiss() {\n            send({\n              type: \"CLOSE\",\n              src: \"interact-outside\"\n            });\n          }\n        });\n      },\n      preventScroll({\n        scope,\n        prop\n      }) {\n        if (!prop(\"preventScroll\")) return;\n        return preventBodyScroll(scope.getDoc());\n      },\n      trapFocus({\n        scope,\n        prop\n      }) {\n        if (!prop(\"trapFocus\")) return;\n        const contentEl = () => getContentEl(scope);\n        return trapFocus(contentEl, {\n          preventScroll: true,\n          returnFocusOnDeactivate: !!prop(\"restoreFocus\"),\n          initialFocus: prop(\"initialFocusEl\"),\n          setReturnFocus: el => prop(\"finalFocusEl\")?.() || el\n        });\n      },\n      hideContentBelow({\n        scope,\n        prop\n      }) {\n        if (!prop(\"modal\")) return;\n        const getElements = () => [getContentEl(scope)];\n        return ariaHidden(getElements, {\n          defer: true\n        });\n      },\n      trackPointerMove({\n        scope,\n        send,\n        prop\n      }) {\n        let lastY = 0;\n        function onPointerMove(event) {\n          const point = getEventPoint(event);\n          const target = getEventTarget(event);\n          send({\n            type: \"POINTER_MOVE\",\n            point,\n            target\n          });\n        }\n        function onPointerUp(event) {\n          if (event.pointerType === \"touch\") return;\n          const point = getEventPoint(event);\n          send({\n            type: \"POINTER_UP\",\n            point\n          });\n        }\n        function onTouchStart(event) {\n          if (!event.touches[0]) return;\n          lastY = event.touches[0].clientY;\n        }\n        function onTouchMove(event) {\n          if (!event.touches[0]) return;\n          const point = getEventPoint(event);\n          const target = event.target;\n          if (!prop(\"preventDragOnScroll\")) {\n            send({\n              type: \"POINTER_MOVE\",\n              point,\n              target\n            });\n            return;\n          }\n          const contentEl = getContentEl(scope);\n          if (!contentEl) return;\n          let el = target;\n          while (el && el !== contentEl && el.scrollHeight <= el.clientHeight) {\n            el = el.parentElement;\n          }\n          if (el && el !== contentEl) {\n            const scrollTop = el.scrollTop;\n            const y = event.touches[0].clientY;\n            const atTop = scrollTop <= 0;\n            if (atTop && y > lastY) {\n              event.preventDefault();\n            }\n            lastY = y;\n          }\n          send({\n            type: \"POINTER_MOVE\",\n            point,\n            target\n          });\n        }\n        function onTouchEnd(event) {\n          if (event.touches.length !== 0) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"POINTER_UP\",\n            point\n          });\n        }\n        const doc = scope.getDoc();\n        const cleanups = [addDomEvent(doc, \"pointermove\", onPointerMove), addDomEvent(doc, \"pointerup\", onPointerUp), addDomEvent(doc, \"touchstart\", onTouchStart, {\n          passive: false\n        }), addDomEvent(doc, \"touchmove\", onTouchMove, {\n          passive: false\n        }), addDomEvent(doc, \"touchend\", onTouchEnd)];\n        return () => {\n          cleanups.forEach(cleanup => cleanup());\n        };\n      },\n      trackContentHeight({\n        context,\n        scope\n      }) {\n        const contentEl = getContentEl(scope);\n        if (!contentEl) return;\n        const win = scope.getWin();\n        const updateHeight = () => {\n          const rect = contentEl.getBoundingClientRect();\n          context.set(\"contentHeight\", rect.height);\n        };\n        updateHeight();\n        const observer = new win.ResizeObserver(() => {\n          updateHeight();\n        });\n        observer.observe(contentEl);\n        return () => {\n          observer.disconnect();\n        };\n      },\n      trackExitAnimation({\n        send,\n        scope\n      }) {\n        let cleanup;\n        const rafCleanup = raf(() => {\n          const contentEl = getContentEl(scope);\n          if (!contentEl) return;\n          const animationName = getComputedStyle(contentEl).animationName;\n          const hasNoAnimation = !animationName || animationName === \"none\";\n          if (hasNoAnimation) {\n            send({\n              type: \"ANIMATION_END\"\n            });\n            return;\n          }\n          const onEnd = event => {\n            const target = getEventTarget(event);\n            if (target === contentEl) {\n              send({\n                type: \"ANIMATION_END\"\n              });\n            }\n          };\n          contentEl.addEventListener(\"animationend\", onEnd);\n          cleanup = () => {\n            contentEl.removeEventListener(\"animationend\", onEnd);\n          };\n        });\n        return () => {\n          rafCleanup();\n          cleanup?.();\n        };\n      }\n    }\n  }\n});\nvar props = createProps()([\"id\", \"ids\", \"dir\", \"modal\", \"initialFocusEl\", \"finalFocusEl\", \"open\", \"defaultOpen\", \"getRootNode\", \"snapPoints\", \"swipeVelocityThreshold\", \"closeThreshold\", \"preventDragOnScroll\", \"closeOnEscape\", \"closeOnInteractOutside\", \"onEscapeKeyDown\", \"onFocusOutside\", \"onInteractOutside\", \"onOpenChange\", \"onPointerDownOutside\", \"onRequestDismiss\", \"preventScroll\", \"restoreFocus\", \"role\", \"trapFocus\", \"defaultActiveSnapPoint\", \"activeSnapPoint\", \"onActiveSnapPointChange\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":{"version":3,"names":["createAnatomy","raf","addDomEvent","getEventTarget","getEventPoint","isLeftClick","createSplitProps","toPx","ariaHidden","createMachine","trackDismissableElement","trapFocus","preventBodyScroll","createProps","__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","anatomy","parts","build","getContentId","ctx","ids","content","id","getTitleId","title","getTriggerId","trigger","getBackdropId","backdrop","getGrabberId","grabber","getGrabberIndicatorId","grabberIndicator","getCloseTriggerId","closeTrigger","getContentEl","getById","getTriggerEl","getCloseTriggerEl","connect","service","normalize","state","send","context","scope","prop","open","hasTag","dragOffset","get","dragging","activeSnapPoint","resolvedActiveSnapPoint","translate","offset","onPointerDown","event","target","hasAttribute","closest","matches","type","point","setOpen","nextOpen","open2","snapPoints","setActiveSnapPoint","snapPoint","activeSnapPoint2","getOpenPercentage","contentHeight","currentOffset","Math","max","min","getActiveSnapIndex","indexOf","getContentHeight","getContentProps","props2","draggable","element","attrs","dir","tabIndex","role","hidden","style","transform","transitionDuration","willChange","getTitleProps","getTriggerProps","button","onClick","getBackdropProps","getGrabberProps","touchAction","getGrabberIndicatorProps","getCloseTriggerProps","findClosestSnapPoint","reduce","acc","curr","closestDiff","abs","currentDiff","isScrollContainer","styles","getComputedStyle","overflow","overflowY","getScrollInfo","container","availableScroll","availableScrollTop","clientHeight","scrollTop","scrollHeight","scrolled","document","documentElement","parentNode","DRAG_START_THRESHOLD","DragManager","constructor","setPointerStart","pointerStart","clearPointerStart","getPointerStart","setDragOffset","resolvedActiveSnapPointOffset","currentTimestamp","Date","getTime","lastPoint","dy","y","lastTimestamp","dt","calculatedVelocity","velocity","Number","isFinite","delta","getDragOffset","clearDragOffset","getVelocity","clearVelocityTracking","clear","shouldStartDragging","preventDragOnScroll","shouldDismiss","swipeVelocityThreshold","closeThreshold","visibleHeight","smallestSnapPoint","isFastSwipe","closeThresholdInPixels","isBelowSmallestSnapPoint","isBelowCloseThreshold","hasEnoughDragToDismiss","resolveSnapPoint","containerHeight","parseFloat","Error","machine","props","alertDialog","initialFocusEl","modal","preventScroll","closeOnInteractOutside","closeOnEscape","restoreFocus","defaultActiveSnapPoint","bindable","defaultValue","onChange","refs","dragManager","computed","resolvedSnapPoints","map","watch","track","action","set","initialState","on","actions","states","tags","effects","POINTER_DOWN","POINTER_MOVE","guard","POINTER_UP","CLOSE","closing","ANIMATION_END","closed","OPEN","implementations","guards","isOpenControlled","isDragging","shouldCloseOnSwipe","invokeOnOpen","invokeOnClose","setClosestSnapPoint","length","closestSnapPoint","resolved","clearActiveSnapPoint","clearResolvedActiveSnapPoint","clearContentHeight","toggleVisibility","previousEvent","getContentEl2","defer","exclude","onInteractOutside","preventDefault","onFocusOutside","onEscapeKeyDown","onPointerDownOutside","onRequestDismiss","onDismiss","src","getDoc","contentEl","returnFocusOnDeactivate","initialFocus","setReturnFocus","el","hideContentBelow","getElements","trackPointerMove","lastY","onPointerMove","onPointerUp","pointerType","onTouchStart","touches","clientY","onTouchMove","parentElement","atTop","onTouchEnd","doc","cleanups","passive","forEach","cleanup","trackContentHeight","win","getWin","updateHeight","rect","getBoundingClientRect","height","observer","ResizeObserver","observe","disconnect","trackExitAnimation","rafCleanup","animationName","hasNoAnimation","onEnd","addEventListener","removeEventListener","splitProps"],"sources":["/Users/ameliamagick/personal-finance-tracker/node_modules/@zag-js/bottom-sheet/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { raf, addDomEvent, getEventTarget, getEventPoint, isLeftClick } from '@zag-js/dom-query';\nimport { createSplitProps, toPx } from '@zag-js/utils';\nimport { ariaHidden } from '@zag-js/aria-hidden';\nimport { createMachine } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { trapFocus } from '@zag-js/focus-trap';\nimport { preventBodyScroll } from '@zag-js/remove-scroll';\nimport { createProps } from '@zag-js/types';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar anatomy = createAnatomy(\"bottom-sheet\").parts(\n  \"content\",\n  \"title\",\n  \"trigger\",\n  \"backdrop\",\n  \"grabber\",\n  \"grabberIndicator\",\n  \"closeTrigger\"\n);\nvar parts = anatomy.build();\nvar getContentId = (ctx) => ctx.ids?.content ?? `bottom-sheet:${ctx.id}:content`;\nvar getTitleId = (ctx) => ctx.ids?.title ?? `bottom-sheet:${ctx.id}:title`;\nvar getTriggerId = (ctx) => ctx.ids?.trigger ?? `bottom-sheet:${ctx.id}:trigger`;\nvar getBackdropId = (ctx) => ctx.ids?.backdrop ?? `bottom-sheet:${ctx.id}:backdrop`;\nvar getGrabberId = (ctx) => ctx.ids?.grabber ?? `bottom-sheet:${ctx.id}:grabber`;\nvar getGrabberIndicatorId = (ctx) => ctx.ids?.grabberIndicator ?? `bottom-sheet:${ctx.id}:grabber-indicator`;\nvar getCloseTriggerId = (ctx) => ctx.ids?.closeTrigger ?? `bottom-sheet:${ctx.id}:close-trigger`;\nvar getContentEl = (ctx) => ctx.getById(getContentId(ctx));\nvar getTriggerEl = (ctx) => ctx.getById(getTriggerId(ctx));\nvar getCloseTriggerEl = (ctx) => ctx.getById(getCloseTriggerId(ctx));\n\n// src/bottom-sheet.connect.ts\nfunction connect(service, normalize) {\n  const { state, send, context, scope, prop } = service;\n  const open = state.hasTag(\"open\");\n  const dragOffset = context.get(\"dragOffset\");\n  const dragging = dragOffset !== null;\n  const activeSnapPoint = context.get(\"activeSnapPoint\");\n  const resolvedActiveSnapPoint = context.get(\"resolvedActiveSnapPoint\");\n  const translate = dragOffset ?? resolvedActiveSnapPoint?.offset;\n  function onPointerDown(event) {\n    if (!isLeftClick(event)) return;\n    const target = getEventTarget(event);\n    if (target?.hasAttribute(\"data-no-drag\") || target?.closest(\"[data-no-drag]\")) return;\n    if (state.matches(\"closing\")) return;\n    send({ type: \"POINTER_DOWN\", point: getEventPoint(event) });\n  }\n  return {\n    open,\n    dragging,\n    setOpen(nextOpen) {\n      const open2 = state.hasTag(\"open\");\n      if (open2 === nextOpen) return;\n      send({ type: nextOpen ? \"OPEN\" : \"CLOSE\" });\n    },\n    snapPoints: prop(\"snapPoints\"),\n    activeSnapPoint,\n    setActiveSnapPoint(snapPoint) {\n      const activeSnapPoint2 = context.get(\"activeSnapPoint\");\n      if (activeSnapPoint2 === snapPoint) return;\n      send({ type: \"ACTIVE_SNAP_POINT.SET\", snapPoint });\n    },\n    getOpenPercentage() {\n      if (!open) return 0;\n      const contentHeight = context.get(\"contentHeight\");\n      if (!contentHeight) return 0;\n      const currentOffset = translate ?? 0;\n      return Math.max(0, Math.min(1, 1 - currentOffset / contentHeight));\n    },\n    getActiveSnapIndex() {\n      const snapPoints = prop(\"snapPoints\");\n      return snapPoints.indexOf(activeSnapPoint);\n    },\n    getContentHeight() {\n      return context.get(\"contentHeight\");\n    },\n    getContentProps(props2 = { draggable: true }) {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: prop(\"dir\"),\n        id: getContentId(scope),\n        tabIndex: -1,\n        role: \"dialog\",\n        \"aria-modal\": prop(\"modal\"),\n        \"aria-labelledby\": getTitleId(scope),\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        style: {\n          transform: \"translate3d(0, var(--bottom-sheet-translate, 0), 0)\",\n          transitionDuration: dragging ? \"0s\" : void 0,\n          \"--bottom-sheet-translate\": toPx(translate),\n          willChange: \"transform\"\n        },\n        onPointerDown(event) {\n          if (!props2.draggable) return;\n          onPointerDown(event);\n        }\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: getTitleId(scope),\n        dir: prop(\"dir\")\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: getTriggerId(scope),\n        type: \"button\",\n        onClick() {\n          send({ type: open ? \"CLOSE\" : \"OPEN\" });\n        }\n      });\n    },\n    getBackdropProps() {\n      return normalize.element({\n        ...parts.backdrop.attrs,\n        id: getBackdropId(scope),\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        style: {\n          willChange: \"opacity\"\n        }\n      });\n    },\n    getGrabberProps() {\n      return normalize.element({\n        ...parts.grabber.attrs,\n        id: getGrabberId(scope),\n        onPointerDown(event) {\n          onPointerDown(event);\n        },\n        style: {\n          touchAction: \"none\"\n        }\n      });\n    },\n    getGrabberIndicatorProps() {\n      return normalize.element({\n        ...parts.grabberIndicator.attrs,\n        id: getGrabberIndicatorId(scope)\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.button({\n        ...parts.closeTrigger.attrs,\n        id: getCloseTriggerId(scope),\n        onClick() {\n          send({ type: \"CLOSE\" });\n        }\n      });\n    }\n  };\n}\n\n// src/utils/find-closest-snap-point.ts\nfunction findClosestSnapPoint(offset, snapPoints) {\n  return snapPoints.reduce((acc, curr) => {\n    const closestDiff = Math.abs(offset - acc.offset);\n    const currentDiff = Math.abs(offset - curr.offset);\n    return currentDiff < closestDiff ? curr : acc;\n  });\n}\n\n// src/utils/get-scroll-info.ts\nfunction isScrollContainer(element) {\n  const styles = getComputedStyle(element);\n  const overflow = styles.overflowY;\n  return overflow === \"auto\" || overflow === \"scroll\";\n}\nfunction getScrollInfo(target, container) {\n  let element = target;\n  let availableScroll = 0;\n  let availableScrollTop = 0;\n  while (element) {\n    const { clientHeight, scrollTop, scrollHeight } = element;\n    const scrolled = scrollHeight - scrollTop - clientHeight;\n    if ((scrollTop !== 0 || scrolled !== 0) && isScrollContainer(element)) {\n      availableScroll += scrolled;\n      availableScrollTop += scrollTop;\n    }\n    if (element === container || element === document.documentElement) break;\n    element = element.parentNode;\n  }\n  return {\n    availableScroll,\n    availableScrollTop\n  };\n}\n\n// src/utils/drag-manager.ts\nvar DRAG_START_THRESHOLD = 0.3;\nvar DragManager = class {\n  constructor() {\n    __publicField(this, \"pointerStart\", null);\n    __publicField(this, \"dragOffset\", null);\n    __publicField(this, \"lastPoint\", null);\n    __publicField(this, \"lastTimestamp\", null);\n    __publicField(this, \"velocity\", null);\n  }\n  setPointerStart(point) {\n    this.pointerStart = point;\n  }\n  clearPointerStart() {\n    this.pointerStart = null;\n  }\n  getPointerStart() {\n    return this.pointerStart;\n  }\n  setDragOffset(point, resolvedActiveSnapPointOffset) {\n    if (!this.pointerStart) return;\n    const currentTimestamp = (/* @__PURE__ */ new Date()).getTime();\n    if (this.lastPoint) {\n      const dy = point.y - this.lastPoint.y;\n      if (this.lastTimestamp) {\n        const dt = currentTimestamp - this.lastTimestamp;\n        if (dt > 0) {\n          const calculatedVelocity = dy / dt * 1e3;\n          this.velocity = Number.isFinite(calculatedVelocity) ? calculatedVelocity : 0;\n        }\n      }\n    }\n    this.lastPoint = point;\n    this.lastTimestamp = currentTimestamp;\n    let delta = this.pointerStart.y - point.y - resolvedActiveSnapPointOffset;\n    if (delta > 0) delta = 0;\n    this.dragOffset = -delta;\n  }\n  getDragOffset() {\n    return this.dragOffset;\n  }\n  clearDragOffset() {\n    this.dragOffset = null;\n  }\n  getVelocity() {\n    return this.velocity;\n  }\n  clearVelocityTracking() {\n    this.lastPoint = null;\n    this.lastTimestamp = null;\n    this.velocity = null;\n  }\n  clear() {\n    this.clearPointerStart();\n    this.clearDragOffset();\n    this.clearVelocityTracking();\n  }\n  shouldStartDragging(point, target, container, preventDragOnScroll) {\n    if (!this.pointerStart || !container) return false;\n    if (preventDragOnScroll) {\n      const delta = this.pointerStart.y - point.y;\n      if (Math.abs(delta) < DRAG_START_THRESHOLD) return false;\n      const { availableScroll, availableScrollTop } = getScrollInfo(target, container);\n      if (delta > 0 && Math.abs(availableScroll) > 1 || delta < 0 && Math.abs(availableScrollTop) > 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  findClosestSnapPoint(snapPoints) {\n    if (this.dragOffset === null) {\n      return snapPoints[0]?.value ?? 1;\n    }\n    const closest = findClosestSnapPoint(this.dragOffset, snapPoints);\n    return closest.value;\n  }\n  shouldDismiss(contentHeight, snapPoints, swipeVelocityThreshold, closeThreshold) {\n    if (this.dragOffset === null || this.velocity === null || contentHeight === null) return false;\n    const visibleHeight = contentHeight - this.dragOffset;\n    const smallestSnapPoint = snapPoints.reduce((acc, curr) => curr.offset > acc.offset ? curr : acc);\n    const isFastSwipe = this.velocity > 0 && this.velocity >= swipeVelocityThreshold;\n    const closeThresholdInPixels = contentHeight * (1 - closeThreshold);\n    const isBelowSmallestSnapPoint = visibleHeight < contentHeight - smallestSnapPoint.offset;\n    const isBelowCloseThreshold = visibleHeight < closeThresholdInPixels;\n    const hasEnoughDragToDismiss = isBelowCloseThreshold && isBelowSmallestSnapPoint || visibleHeight === 0;\n    return isFastSwipe || hasEnoughDragToDismiss;\n  }\n};\n\n// src/utils/resolve-snap-point.ts\nfunction resolveSnapPoint(snapPoint, containerHeight) {\n  if (typeof snapPoint === \"number\") {\n    return {\n      value: snapPoint,\n      offset: containerHeight - snapPoint * containerHeight\n    };\n  }\n  if (typeof snapPoint === \"string\") {\n    return {\n      value: snapPoint,\n      offset: containerHeight - parseFloat(snapPoint)\n    };\n  }\n  throw new Error(`Invalid snap point: ${snapPoint}`);\n}\n\n// src/bottom-sheet.machine.ts\nvar machine = createMachine({\n  props({ props: props2, scope }) {\n    const alertDialog = props2.role === \"alertdialog\";\n    const initialFocusEl = alertDialog ? () => getCloseTriggerEl(scope) : void 0;\n    const modal = typeof props2.modal === \"boolean\" ? props2.modal : true;\n    return {\n      modal,\n      trapFocus: modal,\n      preventScroll: modal,\n      closeOnInteractOutside: true,\n      closeOnEscape: true,\n      restoreFocus: true,\n      initialFocusEl,\n      snapPoints: [1],\n      defaultActiveSnapPoint: 1,\n      swipeVelocityThreshold: 700,\n      closeThreshold: 0.25,\n      preventDragOnScroll: true,\n      ...props2\n    };\n  },\n  context({ bindable, prop }) {\n    return {\n      dragOffset: bindable(() => ({\n        defaultValue: null\n      })),\n      activeSnapPoint: bindable(() => ({\n        defaultValue: prop(\"defaultActiveSnapPoint\"),\n        value: prop(\"activeSnapPoint\"),\n        onChange(value) {\n          return prop(\"onActiveSnapPointChange\")?.({ snapPoint: value });\n        }\n      })),\n      resolvedActiveSnapPoint: bindable(() => ({\n        defaultValue: null\n      })),\n      contentHeight: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  refs() {\n    return {\n      dragManager: new DragManager()\n    };\n  },\n  computed: {\n    resolvedSnapPoints({ context, prop }) {\n      const contentHeight = context.get(\"contentHeight\");\n      if (contentHeight === null) return [];\n      return prop(\"snapPoints\").map((snapPoint) => resolveSnapPoint(snapPoint, contentHeight));\n    }\n  },\n  watch({ track, context, prop, action }) {\n    track([() => context.get(\"activeSnapPoint\"), () => context.get(\"contentHeight\")], () => {\n      const activeSnapPoint = context.get(\"activeSnapPoint\");\n      const contentHeight = context.get(\"contentHeight\");\n      if (contentHeight === null) return;\n      const resolvedActiveSnapPoint = resolveSnapPoint(activeSnapPoint, contentHeight);\n      context.set(\"resolvedActiveSnapPoint\", resolvedActiveSnapPoint);\n    });\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n  },\n  initialState({ prop }) {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"closed\";\n  },\n  on: {\n    \"ACTIVE_SNAP_POINT.SET\": {\n      actions: [\"setActiveSnapPoint\"]\n    }\n  },\n  states: {\n    open: {\n      tags: [\"open\"],\n      effects: [\n        \"trackDismissableElement\",\n        \"preventScroll\",\n        \"trapFocus\",\n        \"hideContentBelow\",\n        \"trackPointerMove\",\n        \"trackContentHeight\"\n      ],\n      on: {\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\"\n        },\n        POINTER_DOWN: {\n          actions: [\"setPointerStart\"]\n        },\n        POINTER_MOVE: [\n          {\n            guard: \"isDragging\",\n            actions: [\"setDragOffset\"]\n          },\n          {\n            guard: \"shouldStartDragging\",\n            actions: [\"setDragOffset\"]\n          }\n        ],\n        POINTER_UP: [\n          {\n            guard: \"shouldCloseOnSwipe\",\n            target: \"closing\"\n          },\n          {\n            guard: \"isDragging\",\n            actions: [\"setClosestSnapPoint\", \"clearPointerStart\", \"clearDragOffset\"]\n          },\n          {\n            actions: [\"clearPointerStart\", \"clearDragOffset\"]\n          }\n        ],\n        CLOSE: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          },\n          {\n            target: \"closing\",\n            actions: [\"invokeOnClose\"]\n          }\n        ]\n      }\n    },\n    closing: {\n      effects: [\"trackExitAnimation\"],\n      on: {\n        ANIMATION_END: {\n          target: \"closed\",\n          actions: [\n            \"invokeOnClose\",\n            \"clearPointerStart\",\n            \"clearDragOffset\",\n            \"clearActiveSnapPoint\",\n            \"clearResolvedActiveSnapPoint\",\n            \"clearContentHeight\",\n            \"clearVelocityTracking\"\n          ]\n        }\n      }\n    },\n    closed: {\n      tags: [\"closed\"],\n      on: {\n        \"CONTROLLED.OPEN\": {\n          target: \"open\"\n        },\n        OPEN: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          },\n          {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }\n        ]\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isOpenControlled: ({ prop }) => prop(\"open\") !== void 0,\n      isDragging({ context }) {\n        return context.get(\"dragOffset\") !== null;\n      },\n      shouldStartDragging({ prop, refs, event, scope }) {\n        const dragManager = refs.get(\"dragManager\");\n        return dragManager.shouldStartDragging(\n          event.point,\n          event.target,\n          getContentEl(scope),\n          prop(\"preventDragOnScroll\")\n        );\n      },\n      shouldCloseOnSwipe({ prop, context, computed, refs }) {\n        const dragManager = refs.get(\"dragManager\");\n        return dragManager.shouldDismiss(\n          context.get(\"contentHeight\"),\n          computed(\"resolvedSnapPoints\"),\n          prop(\"swipeVelocityThreshold\"),\n          prop(\"closeThreshold\")\n        );\n      }\n    },\n    actions: {\n      invokeOnOpen({ prop }) {\n        prop(\"onOpenChange\")?.({ open: true });\n      },\n      invokeOnClose({ prop }) {\n        prop(\"onOpenChange\")?.({ open: false });\n      },\n      setActiveSnapPoint({ context, event }) {\n        context.set(\"activeSnapPoint\", event.snapPoint);\n      },\n      setPointerStart({ event, refs }) {\n        refs.get(\"dragManager\").setPointerStart(event.point);\n      },\n      setDragOffset({ context, event, refs }) {\n        const dragManager = refs.get(\"dragManager\");\n        dragManager.setDragOffset(event.point, context.get(\"resolvedActiveSnapPoint\")?.offset || 0);\n        context.set(\"dragOffset\", dragManager.getDragOffset());\n      },\n      setClosestSnapPoint({ computed, context, refs }) {\n        const snapPoints = computed(\"resolvedSnapPoints\");\n        const contentHeight = context.get(\"contentHeight\");\n        if (!snapPoints.length || contentHeight === null) return;\n        const dragManager = refs.get(\"dragManager\");\n        const closestSnapPoint = dragManager.findClosestSnapPoint(snapPoints);\n        context.set(\"activeSnapPoint\", closestSnapPoint);\n        const resolved = resolveSnapPoint(closestSnapPoint, contentHeight);\n        context.set(\"resolvedActiveSnapPoint\", resolved);\n      },\n      clearDragOffset({ context, refs }) {\n        refs.get(\"dragManager\").clearDragOffset();\n        context.set(\"dragOffset\", null);\n      },\n      clearActiveSnapPoint({ context, prop }) {\n        context.set(\"activeSnapPoint\", prop(\"defaultActiveSnapPoint\"));\n      },\n      clearResolvedActiveSnapPoint({ context }) {\n        context.set(\"resolvedActiveSnapPoint\", null);\n      },\n      clearPointerStart({ refs }) {\n        refs.get(\"dragManager\").clearPointerStart();\n      },\n      clearContentHeight({ context }) {\n        context.set(\"contentHeight\", null);\n      },\n      clearVelocityTracking({ refs }) {\n        refs.get(\"dragManager\").clearVelocityTracking();\n      },\n      toggleVisibility({ event, send, prop }) {\n        send({ type: prop(\"open\") ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\", previousEvent: event });\n      }\n    },\n    effects: {\n      trackDismissableElement({ scope, prop, send }) {\n        const getContentEl2 = () => getContentEl(scope);\n        return trackDismissableElement(getContentEl2, {\n          defer: true,\n          exclude: [getTriggerEl(scope)],\n          onInteractOutside(event) {\n            prop(\"onInteractOutside\")?.(event);\n            if (!prop(\"closeOnInteractOutside\")) {\n              event.preventDefault();\n            }\n          },\n          onFocusOutside: prop(\"onFocusOutside\"),\n          onEscapeKeyDown(event) {\n            prop(\"onEscapeKeyDown\")?.(event);\n            if (!prop(\"closeOnEscape\")) {\n              event.preventDefault();\n            }\n          },\n          onPointerDownOutside: prop(\"onPointerDownOutside\"),\n          onRequestDismiss: prop(\"onRequestDismiss\"),\n          onDismiss() {\n            send({ type: \"CLOSE\", src: \"interact-outside\" });\n          }\n        });\n      },\n      preventScroll({ scope, prop }) {\n        if (!prop(\"preventScroll\")) return;\n        return preventBodyScroll(scope.getDoc());\n      },\n      trapFocus({ scope, prop }) {\n        if (!prop(\"trapFocus\")) return;\n        const contentEl = () => getContentEl(scope);\n        return trapFocus(contentEl, {\n          preventScroll: true,\n          returnFocusOnDeactivate: !!prop(\"restoreFocus\"),\n          initialFocus: prop(\"initialFocusEl\"),\n          setReturnFocus: (el) => prop(\"finalFocusEl\")?.() || el\n        });\n      },\n      hideContentBelow({ scope, prop }) {\n        if (!prop(\"modal\")) return;\n        const getElements = () => [getContentEl(scope)];\n        return ariaHidden(getElements, { defer: true });\n      },\n      trackPointerMove({ scope, send, prop }) {\n        let lastY = 0;\n        function onPointerMove(event) {\n          const point = getEventPoint(event);\n          const target = getEventTarget(event);\n          send({ type: \"POINTER_MOVE\", point, target });\n        }\n        function onPointerUp(event) {\n          if (event.pointerType === \"touch\") return;\n          const point = getEventPoint(event);\n          send({ type: \"POINTER_UP\", point });\n        }\n        function onTouchStart(event) {\n          if (!event.touches[0]) return;\n          lastY = event.touches[0].clientY;\n        }\n        function onTouchMove(event) {\n          if (!event.touches[0]) return;\n          const point = getEventPoint(event);\n          const target = event.target;\n          if (!prop(\"preventDragOnScroll\")) {\n            send({ type: \"POINTER_MOVE\", point, target });\n            return;\n          }\n          const contentEl = getContentEl(scope);\n          if (!contentEl) return;\n          let el = target;\n          while (el && el !== contentEl && el.scrollHeight <= el.clientHeight) {\n            el = el.parentElement;\n          }\n          if (el && el !== contentEl) {\n            const scrollTop = el.scrollTop;\n            const y = event.touches[0].clientY;\n            const atTop = scrollTop <= 0;\n            if (atTop && y > lastY) {\n              event.preventDefault();\n            }\n            lastY = y;\n          }\n          send({ type: \"POINTER_MOVE\", point, target });\n        }\n        function onTouchEnd(event) {\n          if (event.touches.length !== 0) return;\n          const point = getEventPoint(event);\n          send({ type: \"POINTER_UP\", point });\n        }\n        const doc = scope.getDoc();\n        const cleanups = [\n          addDomEvent(doc, \"pointermove\", onPointerMove),\n          addDomEvent(doc, \"pointerup\", onPointerUp),\n          addDomEvent(doc, \"touchstart\", onTouchStart, { passive: false }),\n          addDomEvent(doc, \"touchmove\", onTouchMove, { passive: false }),\n          addDomEvent(doc, \"touchend\", onTouchEnd)\n        ];\n        return () => {\n          cleanups.forEach((cleanup) => cleanup());\n        };\n      },\n      trackContentHeight({ context, scope }) {\n        const contentEl = getContentEl(scope);\n        if (!contentEl) return;\n        const win = scope.getWin();\n        const updateHeight = () => {\n          const rect = contentEl.getBoundingClientRect();\n          context.set(\"contentHeight\", rect.height);\n        };\n        updateHeight();\n        const observer = new win.ResizeObserver(() => {\n          updateHeight();\n        });\n        observer.observe(contentEl);\n        return () => {\n          observer.disconnect();\n        };\n      },\n      trackExitAnimation({ send, scope }) {\n        let cleanup;\n        const rafCleanup = raf(() => {\n          const contentEl = getContentEl(scope);\n          if (!contentEl) return;\n          const animationName = getComputedStyle(contentEl).animationName;\n          const hasNoAnimation = !animationName || animationName === \"none\";\n          if (hasNoAnimation) {\n            send({ type: \"ANIMATION_END\" });\n            return;\n          }\n          const onEnd = (event) => {\n            const target = getEventTarget(event);\n            if (target === contentEl) {\n              send({ type: \"ANIMATION_END\" });\n            }\n          };\n          contentEl.addEventListener(\"animationend\", onEnd);\n          cleanup = () => {\n            contentEl.removeEventListener(\"animationend\", onEnd);\n          };\n        });\n        return () => {\n          rafCleanup();\n          cleanup?.();\n        };\n      }\n    }\n  }\n});\nvar props = createProps()([\n  \"id\",\n  \"ids\",\n  \"dir\",\n  \"modal\",\n  \"initialFocusEl\",\n  \"finalFocusEl\",\n  \"open\",\n  \"defaultOpen\",\n  \"getRootNode\",\n  \"snapPoints\",\n  \"swipeVelocityThreshold\",\n  \"closeThreshold\",\n  \"preventDragOnScroll\",\n  \"closeOnEscape\",\n  \"closeOnInteractOutside\",\n  \"onEscapeKeyDown\",\n  \"onFocusOutside\",\n  \"onInteractOutside\",\n  \"onOpenChange\",\n  \"onPointerDownOutside\",\n  \"onRequestDismiss\",\n  \"preventScroll\",\n  \"restoreFocus\",\n  \"role\",\n  \"trapFocus\",\n  \"defaultActiveSnapPoint\",\n  \"activeSnapPoint\",\n  \"onActiveSnapPointChange\"\n]);\nvar splitProps = createSplitProps(props);\n\nexport { anatomy, connect, machine, props, splitProps };\n"],"mappings":"AAAA,SAASA,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,GAAG,EAAEC,WAAW,EAAEC,cAAc,EAAEC,aAAa,EAAEC,WAAW,QAAQ,mBAAmB;AAChG,SAASC,gBAAgB,EAAEC,IAAI,QAAQ,eAAe;AACtD,SAASC,UAAU,QAAQ,qBAAqB;AAChD,SAASC,aAAa,QAAQ,cAAc;AAC5C,SAASC,uBAAuB,QAAQ,qBAAqB;AAC7D,SAASC,SAAS,QAAQ,oBAAoB;AAC9C,SAASC,iBAAiB,QAAQ,uBAAuB;AACzD,SAASC,WAAW,QAAQ,eAAe;AAE3C,IAAIC,SAAS,GAAGC,MAAM,CAACC,cAAc;AACrC,IAAIC,eAAe,GAAGA,CAACC,GAAG,EAAEC,GAAG,EAAEC,KAAK,KAAKD,GAAG,IAAID,GAAG,GAAGJ,SAAS,CAACI,GAAG,EAAEC,GAAG,EAAE;EAAEE,UAAU,EAAE,IAAI;EAAEC,YAAY,EAAE,IAAI;EAAEC,QAAQ,EAAE,IAAI;EAAEH;AAAM,CAAC,CAAC,GAAGF,GAAG,CAACC,GAAG,CAAC,GAAGC,KAAK;AAC/J,IAAII,aAAa,GAAGA,CAACN,GAAG,EAAEC,GAAG,EAAEC,KAAK,KAAKH,eAAe,CAACC,GAAG,EAAE,OAAOC,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAG,EAAE,GAAGA,GAAG,EAAEC,KAAK,CAAC;AAC9G,IAAIK,OAAO,GAAGzB,aAAa,CAAC,cAAc,CAAC,CAAC0B,KAAK,CAC/C,SAAS,EACT,OAAO,EACP,SAAS,EACT,UAAU,EACV,SAAS,EACT,kBAAkB,EAClB,cACF,CAAC;AACD,IAAIA,KAAK,GAAGD,OAAO,CAACE,KAAK,CAAC,CAAC;AAC3B,IAAIC,YAAY,GAAIC,GAAG,IAAKA,GAAG,CAACC,GAAG,EAAEC,OAAO,IAAI,gBAAgBF,GAAG,CAACG,EAAE,UAAU;AAChF,IAAIC,UAAU,GAAIJ,GAAG,IAAKA,GAAG,CAACC,GAAG,EAAEI,KAAK,IAAI,gBAAgBL,GAAG,CAACG,EAAE,QAAQ;AAC1E,IAAIG,YAAY,GAAIN,GAAG,IAAKA,GAAG,CAACC,GAAG,EAAEM,OAAO,IAAI,gBAAgBP,GAAG,CAACG,EAAE,UAAU;AAChF,IAAIK,aAAa,GAAIR,GAAG,IAAKA,GAAG,CAACC,GAAG,EAAEQ,QAAQ,IAAI,gBAAgBT,GAAG,CAACG,EAAE,WAAW;AACnF,IAAIO,YAAY,GAAIV,GAAG,IAAKA,GAAG,CAACC,GAAG,EAAEU,OAAO,IAAI,gBAAgBX,GAAG,CAACG,EAAE,UAAU;AAChF,IAAIS,qBAAqB,GAAIZ,GAAG,IAAKA,GAAG,CAACC,GAAG,EAAEY,gBAAgB,IAAI,gBAAgBb,GAAG,CAACG,EAAE,oBAAoB;AAC5G,IAAIW,iBAAiB,GAAId,GAAG,IAAKA,GAAG,CAACC,GAAG,EAAEc,YAAY,IAAI,gBAAgBf,GAAG,CAACG,EAAE,gBAAgB;AAChG,IAAIa,YAAY,GAAIhB,GAAG,IAAKA,GAAG,CAACiB,OAAO,CAAClB,YAAY,CAACC,GAAG,CAAC,CAAC;AAC1D,IAAIkB,YAAY,GAAIlB,GAAG,IAAKA,GAAG,CAACiB,OAAO,CAACX,YAAY,CAACN,GAAG,CAAC,CAAC;AAC1D,IAAImB,iBAAiB,GAAInB,GAAG,IAAKA,GAAG,CAACiB,OAAO,CAACH,iBAAiB,CAACd,GAAG,CAAC,CAAC;;AAEpE;AACA,SAASoB,OAAOA,CAACC,OAAO,EAAEC,SAAS,EAAE;EACnC,MAAM;IAAEC,KAAK;IAAEC,IAAI;IAAEC,OAAO;IAAEC,KAAK;IAAEC;EAAK,CAAC,GAAGN,OAAO;EACrD,MAAMO,IAAI,GAAGL,KAAK,CAACM,MAAM,CAAC,MAAM,CAAC;EACjC,MAAMC,UAAU,GAAGL,OAAO,CAACM,GAAG,CAAC,YAAY,CAAC;EAC5C,MAAMC,QAAQ,GAAGF,UAAU,KAAK,IAAI;EACpC,MAAMG,eAAe,GAAGR,OAAO,CAACM,GAAG,CAAC,iBAAiB,CAAC;EACtD,MAAMG,uBAAuB,GAAGT,OAAO,CAACM,GAAG,CAAC,yBAAyB,CAAC;EACtE,MAAMI,SAAS,GAAGL,UAAU,IAAII,uBAAuB,EAAEE,MAAM;EAC/D,SAASC,aAAaA,CAACC,KAAK,EAAE;IAC5B,IAAI,CAAC9D,WAAW,CAAC8D,KAAK,CAAC,EAAE;IACzB,MAAMC,MAAM,GAAGjE,cAAc,CAACgE,KAAK,CAAC;IACpC,IAAIC,MAAM,EAAEC,YAAY,CAAC,cAAc,CAAC,IAAID,MAAM,EAAEE,OAAO,CAAC,gBAAgB,CAAC,EAAE;IAC/E,IAAIlB,KAAK,CAACmB,OAAO,CAAC,SAAS,CAAC,EAAE;IAC9BlB,IAAI,CAAC;MAAEmB,IAAI,EAAE,cAAc;MAAEC,KAAK,EAAErE,aAAa,CAAC+D,KAAK;IAAE,CAAC,CAAC;EAC7D;EACA,OAAO;IACLV,IAAI;IACJI,QAAQ;IACRa,OAAOA,CAACC,QAAQ,EAAE;MAChB,MAAMC,KAAK,GAAGxB,KAAK,CAACM,MAAM,CAAC,MAAM,CAAC;MAClC,IAAIkB,KAAK,KAAKD,QAAQ,EAAE;MACxBtB,IAAI,CAAC;QAAEmB,IAAI,EAAEG,QAAQ,GAAG,MAAM,GAAG;MAAQ,CAAC,CAAC;IAC7C,CAAC;IACDE,UAAU,EAAErB,IAAI,CAAC,YAAY,CAAC;IAC9BM,eAAe;IACfgB,kBAAkBA,CAACC,SAAS,EAAE;MAC5B,MAAMC,gBAAgB,GAAG1B,OAAO,CAACM,GAAG,CAAC,iBAAiB,CAAC;MACvD,IAAIoB,gBAAgB,KAAKD,SAAS,EAAE;MACpC1B,IAAI,CAAC;QAAEmB,IAAI,EAAE,uBAAuB;QAAEO;MAAU,CAAC,CAAC;IACpD,CAAC;IACDE,iBAAiBA,CAAA,EAAG;MAClB,IAAI,CAACxB,IAAI,EAAE,OAAO,CAAC;MACnB,MAAMyB,aAAa,GAAG5B,OAAO,CAACM,GAAG,CAAC,eAAe,CAAC;MAClD,IAAI,CAACsB,aAAa,EAAE,OAAO,CAAC;MAC5B,MAAMC,aAAa,GAAGnB,SAAS,IAAI,CAAC;MACpC,OAAOoB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE,CAAC,GAAGH,aAAa,GAAGD,aAAa,CAAC,CAAC;IACpE,CAAC;IACDK,kBAAkBA,CAAA,EAAG;MACnB,MAAMV,UAAU,GAAGrB,IAAI,CAAC,YAAY,CAAC;MACrC,OAAOqB,UAAU,CAACW,OAAO,CAAC1B,eAAe,CAAC;IAC5C,CAAC;IACD2B,gBAAgBA,CAAA,EAAG;MACjB,OAAOnC,OAAO,CAACM,GAAG,CAAC,eAAe,CAAC;IACrC,CAAC;IACD8B,eAAeA,CAACC,MAAM,GAAG;MAAEC,SAAS,EAAE;IAAK,CAAC,EAAE;MAC5C,OAAOzC,SAAS,CAAC0C,OAAO,CAAC;QACvB,GAAGnE,KAAK,CAACK,OAAO,CAAC+D,KAAK;QACtBC,GAAG,EAAEvC,IAAI,CAAC,KAAK,CAAC;QAChBxB,EAAE,EAAEJ,YAAY,CAAC2B,KAAK,CAAC;QACvByC,QAAQ,EAAE,CAAC,CAAC;QACZC,IAAI,EAAE,QAAQ;QACd,YAAY,EAAEzC,IAAI,CAAC,OAAO,CAAC;QAC3B,iBAAiB,EAAEvB,UAAU,CAACsB,KAAK,CAAC;QACpC2C,MAAM,EAAE,CAACzC,IAAI;QACb,YAAY,EAAEA,IAAI,GAAG,MAAM,GAAG,QAAQ;QACtC0C,KAAK,EAAE;UACLC,SAAS,EAAE,qDAAqD;UAChEC,kBAAkB,EAAExC,QAAQ,GAAG,IAAI,GAAG,KAAK,CAAC;UAC5C,0BAA0B,EAAEtD,IAAI,CAACyD,SAAS,CAAC;UAC3CsC,UAAU,EAAE;QACd,CAAC;QACDpC,aAAaA,CAACC,KAAK,EAAE;UACnB,IAAI,CAACwB,MAAM,CAACC,SAAS,EAAE;UACvB1B,aAAa,CAACC,KAAK,CAAC;QACtB;MACF,CAAC,CAAC;IACJ,CAAC;IACDoC,aAAaA,CAAA,EAAG;MACd,OAAOpD,SAAS,CAAC0C,OAAO,CAAC;QACvB,GAAGnE,KAAK,CAACQ,KAAK,CAAC4D,KAAK;QACpB9D,EAAE,EAAEC,UAAU,CAACsB,KAAK,CAAC;QACrBwC,GAAG,EAAEvC,IAAI,CAAC,KAAK;MACjB,CAAC,CAAC;IACJ,CAAC;IACDgD,eAAeA,CAAA,EAAG;MAChB,OAAOrD,SAAS,CAACsD,MAAM,CAAC;QACtB,GAAG/E,KAAK,CAACU,OAAO,CAAC0D,KAAK;QACtB9D,EAAE,EAAEG,YAAY,CAACoB,KAAK,CAAC;QACvBiB,IAAI,EAAE,QAAQ;QACdkC,OAAOA,CAAA,EAAG;UACRrD,IAAI,CAAC;YAAEmB,IAAI,EAAEf,IAAI,GAAG,OAAO,GAAG;UAAO,CAAC,CAAC;QACzC;MACF,CAAC,CAAC;IACJ,CAAC;IACDkD,gBAAgBA,CAAA,EAAG;MACjB,OAAOxD,SAAS,CAAC0C,OAAO,CAAC;QACvB,GAAGnE,KAAK,CAACY,QAAQ,CAACwD,KAAK;QACvB9D,EAAE,EAAEK,aAAa,CAACkB,KAAK,CAAC;QACxB2C,MAAM,EAAE,CAACzC,IAAI;QACb,YAAY,EAAEA,IAAI,GAAG,MAAM,GAAG,QAAQ;QACtC0C,KAAK,EAAE;UACLG,UAAU,EAAE;QACd;MACF,CAAC,CAAC;IACJ,CAAC;IACDM,eAAeA,CAAA,EAAG;MAChB,OAAOzD,SAAS,CAAC0C,OAAO,CAAC;QACvB,GAAGnE,KAAK,CAACc,OAAO,CAACsD,KAAK;QACtB9D,EAAE,EAAEO,YAAY,CAACgB,KAAK,CAAC;QACvBW,aAAaA,CAACC,KAAK,EAAE;UACnBD,aAAa,CAACC,KAAK,CAAC;QACtB,CAAC;QACDgC,KAAK,EAAE;UACLU,WAAW,EAAE;QACf;MACF,CAAC,CAAC;IACJ,CAAC;IACDC,wBAAwBA,CAAA,EAAG;MACzB,OAAO3D,SAAS,CAAC0C,OAAO,CAAC;QACvB,GAAGnE,KAAK,CAACgB,gBAAgB,CAACoD,KAAK;QAC/B9D,EAAE,EAAES,qBAAqB,CAACc,KAAK;MACjC,CAAC,CAAC;IACJ,CAAC;IACDwD,oBAAoBA,CAAA,EAAG;MACrB,OAAO5D,SAAS,CAACsD,MAAM,CAAC;QACtB,GAAG/E,KAAK,CAACkB,YAAY,CAACkD,KAAK;QAC3B9D,EAAE,EAAEW,iBAAiB,CAACY,KAAK,CAAC;QAC5BmD,OAAOA,CAAA,EAAG;UACRrD,IAAI,CAAC;YAAEmB,IAAI,EAAE;UAAQ,CAAC,CAAC;QACzB;MACF,CAAC,CAAC;IACJ;EACF,CAAC;AACH;;AAEA;AACA,SAASwC,oBAAoBA,CAAC/C,MAAM,EAAEY,UAAU,EAAE;EAChD,OAAOA,UAAU,CAACoC,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAK;IACtC,MAAMC,WAAW,GAAGhC,IAAI,CAACiC,GAAG,CAACpD,MAAM,GAAGiD,GAAG,CAACjD,MAAM,CAAC;IACjD,MAAMqD,WAAW,GAAGlC,IAAI,CAACiC,GAAG,CAACpD,MAAM,GAAGkD,IAAI,CAAClD,MAAM,CAAC;IAClD,OAAOqD,WAAW,GAAGF,WAAW,GAAGD,IAAI,GAAGD,GAAG;EAC/C,CAAC,CAAC;AACJ;;AAEA;AACA,SAASK,iBAAiBA,CAAC1B,OAAO,EAAE;EAClC,MAAM2B,MAAM,GAAGC,gBAAgB,CAAC5B,OAAO,CAAC;EACxC,MAAM6B,QAAQ,GAAGF,MAAM,CAACG,SAAS;EACjC,OAAOD,QAAQ,KAAK,MAAM,IAAIA,QAAQ,KAAK,QAAQ;AACrD;AACA,SAASE,aAAaA,CAACxD,MAAM,EAAEyD,SAAS,EAAE;EACxC,IAAIhC,OAAO,GAAGzB,MAAM;EACpB,IAAI0D,eAAe,GAAG,CAAC;EACvB,IAAIC,kBAAkB,GAAG,CAAC;EAC1B,OAAOlC,OAAO,EAAE;IACd,MAAM;MAAEmC,YAAY;MAAEC,SAAS;MAAEC;IAAa,CAAC,GAAGrC,OAAO;IACzD,MAAMsC,QAAQ,GAAGD,YAAY,GAAGD,SAAS,GAAGD,YAAY;IACxD,IAAI,CAACC,SAAS,KAAK,CAAC,IAAIE,QAAQ,KAAK,CAAC,KAAKZ,iBAAiB,CAAC1B,OAAO,CAAC,EAAE;MACrEiC,eAAe,IAAIK,QAAQ;MAC3BJ,kBAAkB,IAAIE,SAAS;IACjC;IACA,IAAIpC,OAAO,KAAKgC,SAAS,IAAIhC,OAAO,KAAKuC,QAAQ,CAACC,eAAe,EAAE;IACnExC,OAAO,GAAGA,OAAO,CAACyC,UAAU;EAC9B;EACA,OAAO;IACLR,eAAe;IACfC;EACF,CAAC;AACH;;AAEA;AACA,IAAIQ,oBAAoB,GAAG,GAAG;AAC9B,IAAIC,WAAW,GAAG,MAAM;EACtBC,WAAWA,CAAA,EAAG;IACZjH,aAAa,CAAC,IAAI,EAAE,cAAc,EAAE,IAAI,CAAC;IACzCA,aAAa,CAAC,IAAI,EAAE,YAAY,EAAE,IAAI,CAAC;IACvCA,aAAa,CAAC,IAAI,EAAE,WAAW,EAAE,IAAI,CAAC;IACtCA,aAAa,CAAC,IAAI,EAAE,eAAe,EAAE,IAAI,CAAC;IAC1CA,aAAa,CAAC,IAAI,EAAE,UAAU,EAAE,IAAI,CAAC;EACvC;EACAkH,eAAeA,CAACjE,KAAK,EAAE;IACrB,IAAI,CAACkE,YAAY,GAAGlE,KAAK;EAC3B;EACAmE,iBAAiBA,CAAA,EAAG;IAClB,IAAI,CAACD,YAAY,GAAG,IAAI;EAC1B;EACAE,eAAeA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACF,YAAY;EAC1B;EACAG,aAAaA,CAACrE,KAAK,EAAEsE,6BAA6B,EAAE;IAClD,IAAI,CAAC,IAAI,CAACJ,YAAY,EAAE;IACxB,MAAMK,gBAAgB,GAAG,CAAC,eAAgB,IAAIC,IAAI,CAAC,CAAC,EAAEC,OAAO,CAAC,CAAC;IAC/D,IAAI,IAAI,CAACC,SAAS,EAAE;MAClB,MAAMC,EAAE,GAAG3E,KAAK,CAAC4E,CAAC,GAAG,IAAI,CAACF,SAAS,CAACE,CAAC;MACrC,IAAI,IAAI,CAACC,aAAa,EAAE;QACtB,MAAMC,EAAE,GAAGP,gBAAgB,GAAG,IAAI,CAACM,aAAa;QAChD,IAAIC,EAAE,GAAG,CAAC,EAAE;UACV,MAAMC,kBAAkB,GAAGJ,EAAE,GAAGG,EAAE,GAAG,GAAG;UACxC,IAAI,CAACE,QAAQ,GAAGC,MAAM,CAACC,QAAQ,CAACH,kBAAkB,CAAC,GAAGA,kBAAkB,GAAG,CAAC;QAC9E;MACF;IACF;IACA,IAAI,CAACL,SAAS,GAAG1E,KAAK;IACtB,IAAI,CAAC6E,aAAa,GAAGN,gBAAgB;IACrC,IAAIY,KAAK,GAAG,IAAI,CAACjB,YAAY,CAACU,CAAC,GAAG5E,KAAK,CAAC4E,CAAC,GAAGN,6BAA6B;IACzE,IAAIa,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC;IACxB,IAAI,CAACjG,UAAU,GAAG,CAACiG,KAAK;EAC1B;EACAC,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAAClG,UAAU;EACxB;EACAmG,eAAeA,CAAA,EAAG;IAChB,IAAI,CAACnG,UAAU,GAAG,IAAI;EACxB;EACAoG,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACN,QAAQ;EACtB;EACAO,qBAAqBA,CAAA,EAAG;IACtB,IAAI,CAACb,SAAS,GAAG,IAAI;IACrB,IAAI,CAACG,aAAa,GAAG,IAAI;IACzB,IAAI,CAACG,QAAQ,GAAG,IAAI;EACtB;EACAQ,KAAKA,CAAA,EAAG;IACN,IAAI,CAACrB,iBAAiB,CAAC,CAAC;IACxB,IAAI,CAACkB,eAAe,CAAC,CAAC;IACtB,IAAI,CAACE,qBAAqB,CAAC,CAAC;EAC9B;EACAE,mBAAmBA,CAACzF,KAAK,EAAEL,MAAM,EAAEyD,SAAS,EAAEsC,mBAAmB,EAAE;IACjE,IAAI,CAAC,IAAI,CAACxB,YAAY,IAAI,CAACd,SAAS,EAAE,OAAO,KAAK;IAClD,IAAIsC,mBAAmB,EAAE;MACvB,MAAMP,KAAK,GAAG,IAAI,CAACjB,YAAY,CAACU,CAAC,GAAG5E,KAAK,CAAC4E,CAAC;MAC3C,IAAIjE,IAAI,CAACiC,GAAG,CAACuC,KAAK,CAAC,GAAGrB,oBAAoB,EAAE,OAAO,KAAK;MACxD,MAAM;QAAET,eAAe;QAAEC;MAAmB,CAAC,GAAGH,aAAa,CAACxD,MAAM,EAAEyD,SAAS,CAAC;MAChF,IAAI+B,KAAK,GAAG,CAAC,IAAIxE,IAAI,CAACiC,GAAG,CAACS,eAAe,CAAC,GAAG,CAAC,IAAI8B,KAAK,GAAG,CAAC,IAAIxE,IAAI,CAACiC,GAAG,CAACU,kBAAkB,CAAC,GAAG,CAAC,EAAE;QAC/F,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;EACAf,oBAAoBA,CAACnC,UAAU,EAAE;IAC/B,IAAI,IAAI,CAAClB,UAAU,KAAK,IAAI,EAAE;MAC5B,OAAOkB,UAAU,CAAC,CAAC,CAAC,EAAEzD,KAAK,IAAI,CAAC;IAClC;IACA,MAAMkD,OAAO,GAAG0C,oBAAoB,CAAC,IAAI,CAACrD,UAAU,EAAEkB,UAAU,CAAC;IACjE,OAAOP,OAAO,CAAClD,KAAK;EACtB;EACAgJ,aAAaA,CAAClF,aAAa,EAAEL,UAAU,EAAEwF,sBAAsB,EAAEC,cAAc,EAAE;IAC/E,IAAI,IAAI,CAAC3G,UAAU,KAAK,IAAI,IAAI,IAAI,CAAC8F,QAAQ,KAAK,IAAI,IAAIvE,aAAa,KAAK,IAAI,EAAE,OAAO,KAAK;IAC9F,MAAMqF,aAAa,GAAGrF,aAAa,GAAG,IAAI,CAACvB,UAAU;IACrD,MAAM6G,iBAAiB,GAAG3F,UAAU,CAACoC,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAKA,IAAI,CAAClD,MAAM,GAAGiD,GAAG,CAACjD,MAAM,GAAGkD,IAAI,GAAGD,GAAG,CAAC;IACjG,MAAMuD,WAAW,GAAG,IAAI,CAAChB,QAAQ,GAAG,CAAC,IAAI,IAAI,CAACA,QAAQ,IAAIY,sBAAsB;IAChF,MAAMK,sBAAsB,GAAGxF,aAAa,IAAI,CAAC,GAAGoF,cAAc,CAAC;IACnE,MAAMK,wBAAwB,GAAGJ,aAAa,GAAGrF,aAAa,GAAGsF,iBAAiB,CAACvG,MAAM;IACzF,MAAM2G,qBAAqB,GAAGL,aAAa,GAAGG,sBAAsB;IACpE,MAAMG,sBAAsB,GAAGD,qBAAqB,IAAID,wBAAwB,IAAIJ,aAAa,KAAK,CAAC;IACvG,OAAOE,WAAW,IAAII,sBAAsB;EAC9C;AACF,CAAC;;AAED;AACA,SAASC,gBAAgBA,CAAC/F,SAAS,EAAEgG,eAAe,EAAE;EACpD,IAAI,OAAOhG,SAAS,KAAK,QAAQ,EAAE;IACjC,OAAO;MACL3D,KAAK,EAAE2D,SAAS;MAChBd,MAAM,EAAE8G,eAAe,GAAGhG,SAAS,GAAGgG;IACxC,CAAC;EACH;EACA,IAAI,OAAOhG,SAAS,KAAK,QAAQ,EAAE;IACjC,OAAO;MACL3D,KAAK,EAAE2D,SAAS;MAChBd,MAAM,EAAE8G,eAAe,GAAGC,UAAU,CAACjG,SAAS;IAChD,CAAC;EACH;EACA,MAAM,IAAIkG,KAAK,CAAC,uBAAuBlG,SAAS,EAAE,CAAC;AACrD;;AAEA;AACA,IAAImG,OAAO,GAAGzK,aAAa,CAAC;EAC1B0K,KAAKA,CAAC;IAAEA,KAAK,EAAExF,MAAM;IAAEpC;EAAM,CAAC,EAAE;IAC9B,MAAM6H,WAAW,GAAGzF,MAAM,CAACM,IAAI,KAAK,aAAa;IACjD,MAAMoF,cAAc,GAAGD,WAAW,GAAG,MAAMpI,iBAAiB,CAACO,KAAK,CAAC,GAAG,KAAK,CAAC;IAC5E,MAAM+H,KAAK,GAAG,OAAO3F,MAAM,CAAC2F,KAAK,KAAK,SAAS,GAAG3F,MAAM,CAAC2F,KAAK,GAAG,IAAI;IACrE,OAAO;MACLA,KAAK;MACL3K,SAAS,EAAE2K,KAAK;MAChBC,aAAa,EAAED,KAAK;MACpBE,sBAAsB,EAAE,IAAI;MAC5BC,aAAa,EAAE,IAAI;MACnBC,YAAY,EAAE,IAAI;MAClBL,cAAc;MACdxG,UAAU,EAAE,CAAC,CAAC,CAAC;MACf8G,sBAAsB,EAAE,CAAC;MACzBtB,sBAAsB,EAAE,GAAG;MAC3BC,cAAc,EAAE,IAAI;MACpBH,mBAAmB,EAAE,IAAI;MACzB,GAAGxE;IACL,CAAC;EACH,CAAC;EACDrC,OAAOA,CAAC;IAAEsI,QAAQ;IAAEpI;EAAK,CAAC,EAAE;IAC1B,OAAO;MACLG,UAAU,EAAEiI,QAAQ,CAAC,OAAO;QAC1BC,YAAY,EAAE;MAChB,CAAC,CAAC,CAAC;MACH/H,eAAe,EAAE8H,QAAQ,CAAC,OAAO;QAC/BC,YAAY,EAAErI,IAAI,CAAC,wBAAwB,CAAC;QAC5CpC,KAAK,EAAEoC,IAAI,CAAC,iBAAiB,CAAC;QAC9BsI,QAAQA,CAAC1K,KAAK,EAAE;UACd,OAAOoC,IAAI,CAAC,yBAAyB,CAAC,GAAG;YAAEuB,SAAS,EAAE3D;UAAM,CAAC,CAAC;QAChE;MACF,CAAC,CAAC,CAAC;MACH2C,uBAAuB,EAAE6H,QAAQ,CAAC,OAAO;QACvCC,YAAY,EAAE;MAChB,CAAC,CAAC,CAAC;MACH3G,aAAa,EAAE0G,QAAQ,CAAC,OAAO;QAC7BC,YAAY,EAAE;MAChB,CAAC,CAAC;IACJ,CAAC;EACH,CAAC;EACDE,IAAIA,CAAA,EAAG;IACL,OAAO;MACLC,WAAW,EAAE,IAAIxD,WAAW,CAAC;IAC/B,CAAC;EACH,CAAC;EACDyD,QAAQ,EAAE;IACRC,kBAAkBA,CAAC;MAAE5I,OAAO;MAAEE;IAAK,CAAC,EAAE;MACpC,MAAM0B,aAAa,GAAG5B,OAAO,CAACM,GAAG,CAAC,eAAe,CAAC;MAClD,IAAIsB,aAAa,KAAK,IAAI,EAAE,OAAO,EAAE;MACrC,OAAO1B,IAAI,CAAC,YAAY,CAAC,CAAC2I,GAAG,CAAEpH,SAAS,IAAK+F,gBAAgB,CAAC/F,SAAS,EAAEG,aAAa,CAAC,CAAC;IAC1F;EACF,CAAC;EACDkH,KAAKA,CAAC;IAAEC,KAAK;IAAE/I,OAAO;IAAEE,IAAI;IAAE8I;EAAO,CAAC,EAAE;IACtCD,KAAK,CAAC,CAAC,MAAM/I,OAAO,CAACM,GAAG,CAAC,iBAAiB,CAAC,EAAE,MAAMN,OAAO,CAACM,GAAG,CAAC,eAAe,CAAC,CAAC,EAAE,MAAM;MACtF,MAAME,eAAe,GAAGR,OAAO,CAACM,GAAG,CAAC,iBAAiB,CAAC;MACtD,MAAMsB,aAAa,GAAG5B,OAAO,CAACM,GAAG,CAAC,eAAe,CAAC;MAClD,IAAIsB,aAAa,KAAK,IAAI,EAAE;MAC5B,MAAMnB,uBAAuB,GAAG+G,gBAAgB,CAAChH,eAAe,EAAEoB,aAAa,CAAC;MAChF5B,OAAO,CAACiJ,GAAG,CAAC,yBAAyB,EAAExI,uBAAuB,CAAC;IACjE,CAAC,CAAC;IACFsI,KAAK,CAAC,CAAC,MAAM7I,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM;MAChC8I,MAAM,CAAC,CAAC,kBAAkB,CAAC,CAAC;IAC9B,CAAC,CAAC;EACJ,CAAC;EACDE,YAAYA,CAAC;IAAEhJ;EAAK,CAAC,EAAE;IACrB,MAAMC,IAAI,GAAGD,IAAI,CAAC,MAAM,CAAC,IAAIA,IAAI,CAAC,aAAa,CAAC;IAChD,OAAOC,IAAI,GAAG,MAAM,GAAG,QAAQ;EACjC,CAAC;EACDgJ,EAAE,EAAE;IACF,uBAAuB,EAAE;MACvBC,OAAO,EAAE,CAAC,oBAAoB;IAChC;EACF,CAAC;EACDC,MAAM,EAAE;IACNlJ,IAAI,EAAE;MACJmJ,IAAI,EAAE,CAAC,MAAM,CAAC;MACdC,OAAO,EAAE,CACP,yBAAyB,EACzB,eAAe,EACf,WAAW,EACX,kBAAkB,EAClB,kBAAkB,EAClB,oBAAoB,CACrB;MACDJ,EAAE,EAAE;QACF,kBAAkB,EAAE;UAClBrI,MAAM,EAAE;QACV,CAAC;QACD0I,YAAY,EAAE;UACZJ,OAAO,EAAE,CAAC,iBAAiB;QAC7B,CAAC;QACDK,YAAY,EAAE,CACZ;UACEC,KAAK,EAAE,YAAY;UACnBN,OAAO,EAAE,CAAC,eAAe;QAC3B,CAAC,EACD;UACEM,KAAK,EAAE,qBAAqB;UAC5BN,OAAO,EAAE,CAAC,eAAe;QAC3B,CAAC,CACF;QACDO,UAAU,EAAE,CACV;UACED,KAAK,EAAE,oBAAoB;UAC3B5I,MAAM,EAAE;QACV,CAAC,EACD;UACE4I,KAAK,EAAE,YAAY;UACnBN,OAAO,EAAE,CAAC,qBAAqB,EAAE,mBAAmB,EAAE,iBAAiB;QACzE,CAAC,EACD;UACEA,OAAO,EAAE,CAAC,mBAAmB,EAAE,iBAAiB;QAClD,CAAC,CACF;QACDQ,KAAK,EAAE,CACL;UACEF,KAAK,EAAE,kBAAkB;UACzBN,OAAO,EAAE,CAAC,eAAe;QAC3B,CAAC,EACD;UACEtI,MAAM,EAAE,SAAS;UACjBsI,OAAO,EAAE,CAAC,eAAe;QAC3B,CAAC;MAEL;IACF,CAAC;IACDS,OAAO,EAAE;MACPN,OAAO,EAAE,CAAC,oBAAoB,CAAC;MAC/BJ,EAAE,EAAE;QACFW,aAAa,EAAE;UACbhJ,MAAM,EAAE,QAAQ;UAChBsI,OAAO,EAAE,CACP,eAAe,EACf,mBAAmB,EACnB,iBAAiB,EACjB,sBAAsB,EACtB,8BAA8B,EAC9B,oBAAoB,EACpB,uBAAuB;QAE3B;MACF;IACF,CAAC;IACDW,MAAM,EAAE;MACNT,IAAI,EAAE,CAAC,QAAQ,CAAC;MAChBH,EAAE,EAAE;QACF,iBAAiB,EAAE;UACjBrI,MAAM,EAAE;QACV,CAAC;QACDkJ,IAAI,EAAE,CACJ;UACEN,KAAK,EAAE,kBAAkB;UACzBN,OAAO,EAAE,CAAC,cAAc;QAC1B,CAAC,EACD;UACEtI,MAAM,EAAE,MAAM;UACdsI,OAAO,EAAE,CAAC,cAAc;QAC1B,CAAC;MAEL;IACF;EACF,CAAC;EACDa,eAAe,EAAE;IACfC,MAAM,EAAE;MACNC,gBAAgB,EAAEA,CAAC;QAAEjK;MAAK,CAAC,KAAKA,IAAI,CAAC,MAAM,CAAC,KAAK,KAAK,CAAC;MACvDkK,UAAUA,CAAC;QAAEpK;MAAQ,CAAC,EAAE;QACtB,OAAOA,OAAO,CAACM,GAAG,CAAC,YAAY,CAAC,KAAK,IAAI;MAC3C,CAAC;MACDsG,mBAAmBA,CAAC;QAAE1G,IAAI;QAAEuI,IAAI;QAAE5H,KAAK;QAAEZ;MAAM,CAAC,EAAE;QAChD,MAAMyI,WAAW,GAAGD,IAAI,CAACnI,GAAG,CAAC,aAAa,CAAC;QAC3C,OAAOoI,WAAW,CAAC9B,mBAAmB,CACpC/F,KAAK,CAACM,KAAK,EACXN,KAAK,CAACC,MAAM,EACZvB,YAAY,CAACU,KAAK,CAAC,EACnBC,IAAI,CAAC,qBAAqB,CAC5B,CAAC;MACH,CAAC;MACDmK,kBAAkBA,CAAC;QAAEnK,IAAI;QAAEF,OAAO;QAAE2I,QAAQ;QAAEF;MAAK,CAAC,EAAE;QACpD,MAAMC,WAAW,GAAGD,IAAI,CAACnI,GAAG,CAAC,aAAa,CAAC;QAC3C,OAAOoI,WAAW,CAAC5B,aAAa,CAC9B9G,OAAO,CAACM,GAAG,CAAC,eAAe,CAAC,EAC5BqI,QAAQ,CAAC,oBAAoB,CAAC,EAC9BzI,IAAI,CAAC,wBAAwB,CAAC,EAC9BA,IAAI,CAAC,gBAAgB,CACvB,CAAC;MACH;IACF,CAAC;IACDkJ,OAAO,EAAE;MACPkB,YAAYA,CAAC;QAAEpK;MAAK,CAAC,EAAE;QACrBA,IAAI,CAAC,cAAc,CAAC,GAAG;UAAEC,IAAI,EAAE;QAAK,CAAC,CAAC;MACxC,CAAC;MACDoK,aAAaA,CAAC;QAAErK;MAAK,CAAC,EAAE;QACtBA,IAAI,CAAC,cAAc,CAAC,GAAG;UAAEC,IAAI,EAAE;QAAM,CAAC,CAAC;MACzC,CAAC;MACDqB,kBAAkBA,CAAC;QAAExB,OAAO;QAAEa;MAAM,CAAC,EAAE;QACrCb,OAAO,CAACiJ,GAAG,CAAC,iBAAiB,EAAEpI,KAAK,CAACY,SAAS,CAAC;MACjD,CAAC;MACD2D,eAAeA,CAAC;QAAEvE,KAAK;QAAE4H;MAAK,CAAC,EAAE;QAC/BA,IAAI,CAACnI,GAAG,CAAC,aAAa,CAAC,CAAC8E,eAAe,CAACvE,KAAK,CAACM,KAAK,CAAC;MACtD,CAAC;MACDqE,aAAaA,CAAC;QAAExF,OAAO;QAAEa,KAAK;QAAE4H;MAAK,CAAC,EAAE;QACtC,MAAMC,WAAW,GAAGD,IAAI,CAACnI,GAAG,CAAC,aAAa,CAAC;QAC3CoI,WAAW,CAAClD,aAAa,CAAC3E,KAAK,CAACM,KAAK,EAAEnB,OAAO,CAACM,GAAG,CAAC,yBAAyB,CAAC,EAAEK,MAAM,IAAI,CAAC,CAAC;QAC3FX,OAAO,CAACiJ,GAAG,CAAC,YAAY,EAAEP,WAAW,CAACnC,aAAa,CAAC,CAAC,CAAC;MACxD,CAAC;MACDiE,mBAAmBA,CAAC;QAAE7B,QAAQ;QAAE3I,OAAO;QAAEyI;MAAK,CAAC,EAAE;QAC/C,MAAMlH,UAAU,GAAGoH,QAAQ,CAAC,oBAAoB,CAAC;QACjD,MAAM/G,aAAa,GAAG5B,OAAO,CAACM,GAAG,CAAC,eAAe,CAAC;QAClD,IAAI,CAACiB,UAAU,CAACkJ,MAAM,IAAI7I,aAAa,KAAK,IAAI,EAAE;QAClD,MAAM8G,WAAW,GAAGD,IAAI,CAACnI,GAAG,CAAC,aAAa,CAAC;QAC3C,MAAMoK,gBAAgB,GAAGhC,WAAW,CAAChF,oBAAoB,CAACnC,UAAU,CAAC;QACrEvB,OAAO,CAACiJ,GAAG,CAAC,iBAAiB,EAAEyB,gBAAgB,CAAC;QAChD,MAAMC,QAAQ,GAAGnD,gBAAgB,CAACkD,gBAAgB,EAAE9I,aAAa,CAAC;QAClE5B,OAAO,CAACiJ,GAAG,CAAC,yBAAyB,EAAE0B,QAAQ,CAAC;MAClD,CAAC;MACDnE,eAAeA,CAAC;QAAExG,OAAO;QAAEyI;MAAK,CAAC,EAAE;QACjCA,IAAI,CAACnI,GAAG,CAAC,aAAa,CAAC,CAACkG,eAAe,CAAC,CAAC;QACzCxG,OAAO,CAACiJ,GAAG,CAAC,YAAY,EAAE,IAAI,CAAC;MACjC,CAAC;MACD2B,oBAAoBA,CAAC;QAAE5K,OAAO;QAAEE;MAAK,CAAC,EAAE;QACtCF,OAAO,CAACiJ,GAAG,CAAC,iBAAiB,EAAE/I,IAAI,CAAC,wBAAwB,CAAC,CAAC;MAChE,CAAC;MACD2K,4BAA4BA,CAAC;QAAE7K;MAAQ,CAAC,EAAE;QACxCA,OAAO,CAACiJ,GAAG,CAAC,yBAAyB,EAAE,IAAI,CAAC;MAC9C,CAAC;MACD3D,iBAAiBA,CAAC;QAAEmD;MAAK,CAAC,EAAE;QAC1BA,IAAI,CAACnI,GAAG,CAAC,aAAa,CAAC,CAACgF,iBAAiB,CAAC,CAAC;MAC7C,CAAC;MACDwF,kBAAkBA,CAAC;QAAE9K;MAAQ,CAAC,EAAE;QAC9BA,OAAO,CAACiJ,GAAG,CAAC,eAAe,EAAE,IAAI,CAAC;MACpC,CAAC;MACDvC,qBAAqBA,CAAC;QAAE+B;MAAK,CAAC,EAAE;QAC9BA,IAAI,CAACnI,GAAG,CAAC,aAAa,CAAC,CAACoG,qBAAqB,CAAC,CAAC;MACjD,CAAC;MACDqE,gBAAgBA,CAAC;QAAElK,KAAK;QAAEd,IAAI;QAAEG;MAAK,CAAC,EAAE;QACtCH,IAAI,CAAC;UAAEmB,IAAI,EAAEhB,IAAI,CAAC,MAAM,CAAC,GAAG,iBAAiB,GAAG,kBAAkB;UAAE8K,aAAa,EAAEnK;QAAM,CAAC,CAAC;MAC7F;IACF,CAAC;IACD0I,OAAO,EAAE;MACPnM,uBAAuBA,CAAC;QAAE6C,KAAK;QAAEC,IAAI;QAAEH;MAAK,CAAC,EAAE;QAC7C,MAAMkL,aAAa,GAAGA,CAAA,KAAM1L,YAAY,CAACU,KAAK,CAAC;QAC/C,OAAO7C,uBAAuB,CAAC6N,aAAa,EAAE;UAC5CC,KAAK,EAAE,IAAI;UACXC,OAAO,EAAE,CAAC1L,YAAY,CAACQ,KAAK,CAAC,CAAC;UAC9BmL,iBAAiBA,CAACvK,KAAK,EAAE;YACvBX,IAAI,CAAC,mBAAmB,CAAC,GAAGW,KAAK,CAAC;YAClC,IAAI,CAACX,IAAI,CAAC,wBAAwB,CAAC,EAAE;cACnCW,KAAK,CAACwK,cAAc,CAAC,CAAC;YACxB;UACF,CAAC;UACDC,cAAc,EAAEpL,IAAI,CAAC,gBAAgB,CAAC;UACtCqL,eAAeA,CAAC1K,KAAK,EAAE;YACrBX,IAAI,CAAC,iBAAiB,CAAC,GAAGW,KAAK,CAAC;YAChC,IAAI,CAACX,IAAI,CAAC,eAAe,CAAC,EAAE;cAC1BW,KAAK,CAACwK,cAAc,CAAC,CAAC;YACxB;UACF,CAAC;UACDG,oBAAoB,EAAEtL,IAAI,CAAC,sBAAsB,CAAC;UAClDuL,gBAAgB,EAAEvL,IAAI,CAAC,kBAAkB,CAAC;UAC1CwL,SAASA,CAAA,EAAG;YACV3L,IAAI,CAAC;cAAEmB,IAAI,EAAE,OAAO;cAAEyK,GAAG,EAAE;YAAmB,CAAC,CAAC;UAClD;QACF,CAAC,CAAC;MACJ,CAAC;MACD1D,aAAaA,CAAC;QAAEhI,KAAK;QAAEC;MAAK,CAAC,EAAE;QAC7B,IAAI,CAACA,IAAI,CAAC,eAAe,CAAC,EAAE;QAC5B,OAAO5C,iBAAiB,CAAC2C,KAAK,CAAC2L,MAAM,CAAC,CAAC,CAAC;MAC1C,CAAC;MACDvO,SAASA,CAAC;QAAE4C,KAAK;QAAEC;MAAK,CAAC,EAAE;QACzB,IAAI,CAACA,IAAI,CAAC,WAAW,CAAC,EAAE;QACxB,MAAM2L,SAAS,GAAGA,CAAA,KAAMtM,YAAY,CAACU,KAAK,CAAC;QAC3C,OAAO5C,SAAS,CAACwO,SAAS,EAAE;UAC1B5D,aAAa,EAAE,IAAI;UACnB6D,uBAAuB,EAAE,CAAC,CAAC5L,IAAI,CAAC,cAAc,CAAC;UAC/C6L,YAAY,EAAE7L,IAAI,CAAC,gBAAgB,CAAC;UACpC8L,cAAc,EAAGC,EAAE,IAAK/L,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI+L;QACtD,CAAC,CAAC;MACJ,CAAC;MACDC,gBAAgBA,CAAC;QAAEjM,KAAK;QAAEC;MAAK,CAAC,EAAE;QAChC,IAAI,CAACA,IAAI,CAAC,OAAO,CAAC,EAAE;QACpB,MAAMiM,WAAW,GAAGA,CAAA,KAAM,CAAC5M,YAAY,CAACU,KAAK,CAAC,CAAC;QAC/C,OAAO/C,UAAU,CAACiP,WAAW,EAAE;UAAEjB,KAAK,EAAE;QAAK,CAAC,CAAC;MACjD,CAAC;MACDkB,gBAAgBA,CAAC;QAAEnM,KAAK;QAAEF,IAAI;QAAEG;MAAK,CAAC,EAAE;QACtC,IAAImM,KAAK,GAAG,CAAC;QACb,SAASC,aAAaA,CAACzL,KAAK,EAAE;UAC5B,MAAMM,KAAK,GAAGrE,aAAa,CAAC+D,KAAK,CAAC;UAClC,MAAMC,MAAM,GAAGjE,cAAc,CAACgE,KAAK,CAAC;UACpCd,IAAI,CAAC;YAAEmB,IAAI,EAAE,cAAc;YAAEC,KAAK;YAAEL;UAAO,CAAC,CAAC;QAC/C;QACA,SAASyL,WAAWA,CAAC1L,KAAK,EAAE;UAC1B,IAAIA,KAAK,CAAC2L,WAAW,KAAK,OAAO,EAAE;UACnC,MAAMrL,KAAK,GAAGrE,aAAa,CAAC+D,KAAK,CAAC;UAClCd,IAAI,CAAC;YAAEmB,IAAI,EAAE,YAAY;YAAEC;UAAM,CAAC,CAAC;QACrC;QACA,SAASsL,YAAYA,CAAC5L,KAAK,EAAE;UAC3B,IAAI,CAACA,KAAK,CAAC6L,OAAO,CAAC,CAAC,CAAC,EAAE;UACvBL,KAAK,GAAGxL,KAAK,CAAC6L,OAAO,CAAC,CAAC,CAAC,CAACC,OAAO;QAClC;QACA,SAASC,WAAWA,CAAC/L,KAAK,EAAE;UAC1B,IAAI,CAACA,KAAK,CAAC6L,OAAO,CAAC,CAAC,CAAC,EAAE;UACvB,MAAMvL,KAAK,GAAGrE,aAAa,CAAC+D,KAAK,CAAC;UAClC,MAAMC,MAAM,GAAGD,KAAK,CAACC,MAAM;UAC3B,IAAI,CAACZ,IAAI,CAAC,qBAAqB,CAAC,EAAE;YAChCH,IAAI,CAAC;cAAEmB,IAAI,EAAE,cAAc;cAAEC,KAAK;cAAEL;YAAO,CAAC,CAAC;YAC7C;UACF;UACA,MAAM+K,SAAS,GAAGtM,YAAY,CAACU,KAAK,CAAC;UACrC,IAAI,CAAC4L,SAAS,EAAE;UAChB,IAAII,EAAE,GAAGnL,MAAM;UACf,OAAOmL,EAAE,IAAIA,EAAE,KAAKJ,SAAS,IAAII,EAAE,CAACrH,YAAY,IAAIqH,EAAE,CAACvH,YAAY,EAAE;YACnEuH,EAAE,GAAGA,EAAE,CAACY,aAAa;UACvB;UACA,IAAIZ,EAAE,IAAIA,EAAE,KAAKJ,SAAS,EAAE;YAC1B,MAAMlH,SAAS,GAAGsH,EAAE,CAACtH,SAAS;YAC9B,MAAMoB,CAAC,GAAGlF,KAAK,CAAC6L,OAAO,CAAC,CAAC,CAAC,CAACC,OAAO;YAClC,MAAMG,KAAK,GAAGnI,SAAS,IAAI,CAAC;YAC5B,IAAImI,KAAK,IAAI/G,CAAC,GAAGsG,KAAK,EAAE;cACtBxL,KAAK,CAACwK,cAAc,CAAC,CAAC;YACxB;YACAgB,KAAK,GAAGtG,CAAC;UACX;UACAhG,IAAI,CAAC;YAAEmB,IAAI,EAAE,cAAc;YAAEC,KAAK;YAAEL;UAAO,CAAC,CAAC;QAC/C;QACA,SAASiM,UAAUA,CAAClM,KAAK,EAAE;UACzB,IAAIA,KAAK,CAAC6L,OAAO,CAACjC,MAAM,KAAK,CAAC,EAAE;UAChC,MAAMtJ,KAAK,GAAGrE,aAAa,CAAC+D,KAAK,CAAC;UAClCd,IAAI,CAAC;YAAEmB,IAAI,EAAE,YAAY;YAAEC;UAAM,CAAC,CAAC;QACrC;QACA,MAAM6L,GAAG,GAAG/M,KAAK,CAAC2L,MAAM,CAAC,CAAC;QAC1B,MAAMqB,QAAQ,GAAG,CACfrQ,WAAW,CAACoQ,GAAG,EAAE,aAAa,EAAEV,aAAa,CAAC,EAC9C1P,WAAW,CAACoQ,GAAG,EAAE,WAAW,EAAET,WAAW,CAAC,EAC1C3P,WAAW,CAACoQ,GAAG,EAAE,YAAY,EAAEP,YAAY,EAAE;UAAES,OAAO,EAAE;QAAM,CAAC,CAAC,EAChEtQ,WAAW,CAACoQ,GAAG,EAAE,WAAW,EAAEJ,WAAW,EAAE;UAAEM,OAAO,EAAE;QAAM,CAAC,CAAC,EAC9DtQ,WAAW,CAACoQ,GAAG,EAAE,UAAU,EAAED,UAAU,CAAC,CACzC;QACD,OAAO,MAAM;UACXE,QAAQ,CAACE,OAAO,CAAEC,OAAO,IAAKA,OAAO,CAAC,CAAC,CAAC;QAC1C,CAAC;MACH,CAAC;MACDC,kBAAkBA,CAAC;QAAErN,OAAO;QAAEC;MAAM,CAAC,EAAE;QACrC,MAAM4L,SAAS,GAAGtM,YAAY,CAACU,KAAK,CAAC;QACrC,IAAI,CAAC4L,SAAS,EAAE;QAChB,MAAMyB,GAAG,GAAGrN,KAAK,CAACsN,MAAM,CAAC,CAAC;QAC1B,MAAMC,YAAY,GAAGA,CAAA,KAAM;UACzB,MAAMC,IAAI,GAAG5B,SAAS,CAAC6B,qBAAqB,CAAC,CAAC;UAC9C1N,OAAO,CAACiJ,GAAG,CAAC,eAAe,EAAEwE,IAAI,CAACE,MAAM,CAAC;QAC3C,CAAC;QACDH,YAAY,CAAC,CAAC;QACd,MAAMI,QAAQ,GAAG,IAAIN,GAAG,CAACO,cAAc,CAAC,MAAM;UAC5CL,YAAY,CAAC,CAAC;QAChB,CAAC,CAAC;QACFI,QAAQ,CAACE,OAAO,CAACjC,SAAS,CAAC;QAC3B,OAAO,MAAM;UACX+B,QAAQ,CAACG,UAAU,CAAC,CAAC;QACvB,CAAC;MACH,CAAC;MACDC,kBAAkBA,CAAC;QAAEjO,IAAI;QAAEE;MAAM,CAAC,EAAE;QAClC,IAAImN,OAAO;QACX,MAAMa,UAAU,GAAGtR,GAAG,CAAC,MAAM;UAC3B,MAAMkP,SAAS,GAAGtM,YAAY,CAACU,KAAK,CAAC;UACrC,IAAI,CAAC4L,SAAS,EAAE;UAChB,MAAMqC,aAAa,GAAG/J,gBAAgB,CAAC0H,SAAS,CAAC,CAACqC,aAAa;UAC/D,MAAMC,cAAc,GAAG,CAACD,aAAa,IAAIA,aAAa,KAAK,MAAM;UACjE,IAAIC,cAAc,EAAE;YAClBpO,IAAI,CAAC;cAAEmB,IAAI,EAAE;YAAgB,CAAC,CAAC;YAC/B;UACF;UACA,MAAMkN,KAAK,GAAIvN,KAAK,IAAK;YACvB,MAAMC,MAAM,GAAGjE,cAAc,CAACgE,KAAK,CAAC;YACpC,IAAIC,MAAM,KAAK+K,SAAS,EAAE;cACxB9L,IAAI,CAAC;gBAAEmB,IAAI,EAAE;cAAgB,CAAC,CAAC;YACjC;UACF,CAAC;UACD2K,SAAS,CAACwC,gBAAgB,CAAC,cAAc,EAAED,KAAK,CAAC;UACjDhB,OAAO,GAAGA,CAAA,KAAM;YACdvB,SAAS,CAACyC,mBAAmB,CAAC,cAAc,EAAEF,KAAK,CAAC;UACtD,CAAC;QACH,CAAC,CAAC;QACF,OAAO,MAAM;UACXH,UAAU,CAAC,CAAC;UACZb,OAAO,GAAG,CAAC;QACb,CAAC;MACH;IACF;EACF;AACF,CAAC,CAAC;AACF,IAAIvF,KAAK,GAAGtK,WAAW,CAAC,CAAC,CAAC,CACxB,IAAI,EACJ,KAAK,EACL,KAAK,EACL,OAAO,EACP,gBAAgB,EAChB,cAAc,EACd,MAAM,EACN,aAAa,EACb,aAAa,EACb,YAAY,EACZ,wBAAwB,EACxB,gBAAgB,EAChB,qBAAqB,EACrB,eAAe,EACf,wBAAwB,EACxB,iBAAiB,EACjB,gBAAgB,EAChB,mBAAmB,EACnB,cAAc,EACd,sBAAsB,EACtB,kBAAkB,EAClB,eAAe,EACf,cAAc,EACd,MAAM,EACN,WAAW,EACX,wBAAwB,EACxB,iBAAiB,EACjB,yBAAyB,CAC1B,CAAC;AACF,IAAIgR,UAAU,GAAGvR,gBAAgB,CAAC6K,KAAK,CAAC;AAExC,SAAS1J,OAAO,EAAEwB,OAAO,EAAEiI,OAAO,EAAEC,KAAK,EAAE0G,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}