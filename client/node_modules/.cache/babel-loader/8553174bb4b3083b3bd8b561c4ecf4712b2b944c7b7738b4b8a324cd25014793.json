{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, query, addDomEvent, getComputedStyle, dataAttr, getEventPoint, contains, getEventTarget } from '@zag-js/dom-query';\nimport { callAll, isEqual, clampValue, ensureProps, createSplitProps, toPx, compact } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar anatomy = createAnatomy(\"scroll-area\").parts(\"root\", \"viewport\", \"content\", \"scrollbar\", \"thumb\", \"corner\");\nvar parts = anatomy.build();\nvar getRootId = ctx => ctx.ids?.root ?? `scroll-area-${ctx.id}`;\nvar getViewportId = ctx => ctx.ids?.viewport ?? `scroll-area-${ctx.id}:viewport`;\nvar getContentId = ctx => ctx.ids?.content ?? `scroll-area-${ctx.id}:content`;\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getViewportEl = ctx => ctx.getById(getViewportId(ctx));\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getScrollbarXEl = ctx => query(getRootEl(ctx), `[data-part=scrollbar][data-orientation=horizontal][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getScrollbarYEl = ctx => query(getRootEl(ctx), `[data-part=scrollbar][data-orientation=vertical][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getThumbXEl = ctx => query(getScrollbarXEl(ctx), `[data-part=thumb][data-orientation=horizontal][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getThumbYEl = ctx => query(getScrollbarYEl(ctx), `[data-part=thumb][data-orientation=vertical][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getCornerEl = ctx => query(getRootEl(ctx), `[data-part=corner][data-ownedby=\"${getRootId(ctx)}\"]`);\n\n// src/utils/scroll-progress.ts\nfunction getScrollProgress(element, scrollThreshold) {\n  if (!element) return EMPTY_SCROLL_PROGRESS;\n  let progressX = 0;\n  let progressY = 0;\n  const maxScrollX = element.scrollWidth - element.clientWidth;\n  if (maxScrollX > scrollThreshold) {\n    progressX = Math.min(1, Math.max(0, element.scrollLeft / maxScrollX));\n  }\n  const maxScrollY = element.scrollHeight - element.clientHeight;\n  if (maxScrollY > scrollThreshold) {\n    progressY = Math.min(1, Math.max(0, element.scrollTop / maxScrollY));\n  }\n  return {\n    x: progressX,\n    y: progressY\n  };\n}\nvar EMPTY_SCROLL_PROGRESS = {\n  x: 0,\n  y: 0\n};\n\n// src/utils/smooth-scroll.ts\nvar DURATION = 300;\nvar EASE_OUT_QUAD = t => t * (2 - t);\nfunction smoothScroll(node, options = {}) {\n  const {\n    top,\n    left,\n    duration = DURATION,\n    easing = EASE_OUT_QUAD,\n    onComplete\n  } = options;\n  if (!node) return;\n  const state = {\n    startTime: 0,\n    startScrollTop: node.scrollTop,\n    startScrollLeft: node.scrollLeft,\n    targetScrollTop: top ?? node.scrollTop,\n    targetScrollLeft: left ?? node.scrollLeft\n  };\n  let cancelled = false;\n  const cleanup = () => {\n    if (state.rafId) {\n      cancelAnimationFrame(state.rafId);\n      state.rafId = void 0;\n    }\n    cancelled = true;\n  };\n  const animate = currentTime => {\n    if (cancelled) return;\n    if (state.startTime === 0) {\n      state.startTime = currentTime;\n    }\n    const elapsed = currentTime - state.startTime;\n    const progress = Math.min(elapsed / duration, 1);\n    const easedProgress = easing(progress);\n    const deltaTop = state.targetScrollTop - state.startScrollTop;\n    const deltaLeft = state.targetScrollLeft - state.startScrollLeft;\n    node.scrollTop = state.startScrollTop + deltaTop * easedProgress;\n    node.scrollLeft = state.startScrollLeft + deltaLeft * easedProgress;\n    if (progress < 1) {\n      state.rafId = requestAnimationFrame(animate);\n    } else {\n      onComplete?.();\n    }\n  };\n  state.rafId = requestAnimationFrame(animate);\n  return cleanup;\n}\n\n// src/utils/scroll-to.ts\nfunction scrollTo(node, options = {}) {\n  if (!node) return;\n  const {\n    top,\n    left,\n    behavior = \"smooth\",\n    easing,\n    duration\n  } = options;\n  if (behavior === \"smooth\") {\n    smoothScroll(node, {\n      top,\n      left,\n      easing,\n      duration\n    });\n  } else {\n    const scrollOptions = compact({\n      behavior,\n      top,\n      left\n    });\n    node.scrollTo(scrollOptions);\n  }\n}\nfunction scrollToEdge(node, edge, dir, behavior = \"smooth\", easing, duration) {\n  if (!node) return;\n  const maxLeft = node.scrollWidth - node.clientWidth;\n  const maxTop = node.scrollHeight - node.clientHeight;\n  const isRtl = dir === \"rtl\";\n  let targetScrollTop;\n  let targetScrollLeft;\n  switch (edge) {\n    case \"top\":\n      targetScrollTop = 0;\n      break;\n    case \"bottom\":\n      targetScrollTop = maxTop;\n      break;\n    case \"left\":\n      if (isRtl) {\n        const negative = node.scrollLeft <= 0;\n        targetScrollLeft = negative ? -maxLeft : 0;\n      } else {\n        targetScrollLeft = 0;\n      }\n      break;\n    case \"right\":\n      if (isRtl) {\n        const negative = node.scrollLeft <= 0;\n        targetScrollLeft = negative ? 0 : maxLeft;\n      } else {\n        targetScrollLeft = maxLeft;\n      }\n      break;\n  }\n  if (behavior === \"smooth\") {\n    smoothScroll(node, {\n      top: targetScrollTop,\n      left: targetScrollLeft,\n      easing,\n      duration\n    });\n  } else {\n    const options = compact({\n      left: targetScrollLeft,\n      top: targetScrollTop,\n      behavior\n    });\n    node.scrollTo(options);\n  }\n}\n\n// src/scroll-area.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    context,\n    prop,\n    scope\n  } = service;\n  const dragging = state.matches(\"dragging\");\n  const hovering = context.get(\"hovering\");\n  const cornerSize = context.get(\"cornerSize\");\n  const thumbSize = context.get(\"thumbSize\");\n  const hiddenState = context.get(\"hiddenState\");\n  const atSides = context.get(\"atSides\");\n  return {\n    isAtTop: atSides.top,\n    isAtBottom: atSides.bottom,\n    isAtLeft: atSides.left,\n    isAtRight: atSides.right,\n    hasOverflowX: !hiddenState.scrollbarXHidden,\n    hasOverflowY: !hiddenState.scrollbarYHidden,\n    getScrollProgress() {\n      return getScrollProgress(getViewportEl(scope), 0);\n    },\n    scrollToEdge(details) {\n      const {\n        edge,\n        behavior\n      } = details;\n      return scrollToEdge(getViewportEl(scope), edge, prop(\"dir\"), behavior);\n    },\n    scrollTo(details) {\n      return scrollTo(getViewportEl(scope), details);\n    },\n    getScrollbarState(props2) {\n      const horizontal = props2.orientation === \"horizontal\";\n      return {\n        hovering,\n        dragging,\n        scrolling: context.get(horizontal ? \"scrollingX\" : \"scrollingY\"),\n        hidden: horizontal ? hiddenState.scrollbarXHidden : hiddenState.scrollbarYHidden\n      };\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        role: \"presentation\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        onPointerEnter(event) {\n          const target = getEventTarget(event);\n          if (!contains(event.currentTarget, target)) return;\n          send({\n            type: \"root.pointerenter\",\n            pointerType: event.pointerType\n          });\n        },\n        onPointerMove(event) {\n          const target = getEventTarget(event);\n          if (!contains(event.currentTarget, target)) return;\n          send({\n            type: \"root.pointerenter\",\n            pointerType: event.pointerType\n          });\n        },\n        onPointerDown({\n          pointerType\n        }) {\n          send({\n            type: \"root.pointerdown\",\n            pointerType\n          });\n        },\n        onPointerLeave(event) {\n          if (contains(event.currentTarget, event.relatedTarget)) return;\n          send({\n            type: \"root.pointerleave\"\n          });\n        },\n        style: {\n          position: \"relative\",\n          \"--corner-width\": toPx(cornerSize?.width),\n          \"--corner-height\": toPx(cornerSize?.height),\n          \"--thumb-width\": toPx(thumbSize?.width),\n          \"--thumb-height\": toPx(thumbSize?.height)\n        }\n      });\n    },\n    getViewportProps() {\n      const handleUserInteraction = () => {\n        send({\n          type: \"user.scroll\"\n        });\n      };\n      return normalize.element({\n        ...parts.viewport.attrs,\n        role: \"presentation\",\n        \"data-ownedby\": getRootId(scope),\n        id: getViewportId(scope),\n        \"data-at-top\": dataAttr(atSides.top),\n        \"data-at-bottom\": dataAttr(atSides.bottom),\n        \"data-at-left\": dataAttr(atSides.left),\n        \"data-at-right\": dataAttr(atSides.right),\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        tabIndex: hiddenState.scrollbarXHidden || hiddenState.scrollbarYHidden ? void 0 : 0,\n        style: {\n          overflow: \"auto\"\n        },\n        onScroll(event) {\n          send({\n            type: \"viewport.scroll\",\n            target: event.currentTarget\n          });\n        },\n        onWheel: handleUserInteraction,\n        onTouchMove: handleUserInteraction,\n        onPointerMove: handleUserInteraction,\n        onPointerEnter: handleUserInteraction,\n        onKeyDown: handleUserInteraction\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        id: getContentId(scope),\n        role: \"presentation\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        style: {\n          minWidth: \"fit-content\"\n        }\n      });\n    },\n    getScrollbarProps(props2 = {}) {\n      const {\n        orientation = \"vertical\"\n      } = props2;\n      return normalize.element({\n        ...parts.scrollbar.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-orientation\": orientation,\n        \"data-scrolling\": dataAttr(context.get(orientation === \"horizontal\" ? \"scrollingX\" : \"scrollingY\")),\n        \"data-hover\": dataAttr(hovering),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        onPointerUp() {\n          send({\n            type: \"scrollbar.pointerup\",\n            orientation\n          });\n        },\n        onPointerDown(event) {\n          if (event.button !== 0) {\n            return;\n          }\n          if (event.currentTarget !== event.target) {\n            return;\n          }\n          const point = getEventPoint(event);\n          send({\n            type: \"scrollbar.pointerdown\",\n            orientation,\n            point\n          });\n          event.stopPropagation();\n        },\n        style: {\n          position: \"absolute\",\n          touchAction: \"none\",\n          WebkitUserSelect: \"none\",\n          userSelect: \"none\",\n          ...(orientation === \"vertical\" && {\n            top: 0,\n            bottom: `var(--corner-height)`,\n            insetInlineEnd: 0\n          }),\n          ...(orientation === \"horizontal\" && {\n            insetInlineStart: 0,\n            insetInlineEnd: `var(--corner-width)`,\n            bottom: 0\n          })\n        }\n      });\n    },\n    getThumbProps(props2 = {}) {\n      const {\n        orientation = \"vertical\"\n      } = props2;\n      return normalize.element({\n        ...parts.thumb.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-orientation\": orientation,\n        \"data-hover\": dataAttr(hovering),\n        \"data-dragging\": dataAttr(dragging),\n        onPointerDown(event) {\n          if (event.button !== 0) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"thumb.pointerdown\",\n            orientation,\n            point\n          });\n        },\n        style: {\n          ...(orientation === \"vertical\" && {\n            height: \"var(--thumb-height)\"\n          }),\n          ...(orientation === \"horizontal\" && {\n            width: \"var(--thumb-width)\"\n          })\n        }\n      });\n    },\n    getCornerProps() {\n      return normalize.element({\n        ...parts.corner.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-hover\": dataAttr(hovering),\n        \"data-state\": hiddenState.cornerHidden ? \"hidden\" : \"visible\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        style: {\n          position: \"absolute\",\n          bottom: 0,\n          insetInlineEnd: 0,\n          width: \"var(--corner-width)\",\n          height: \"var(--corner-height)\"\n        }\n      });\n    }\n  };\n}\nfunction getScrollOffset(element, prop, axis) {\n  if (!element) return 0;\n  const styles = getComputedStyle(element);\n  const propAxis = axis === \"x\" ? \"Inline\" : \"Block\";\n  if (axis === \"x\" && prop === \"margin\") {\n    return parseFloat(styles[`${prop}InlineStart`]) * 2;\n  }\n  return parseFloat(styles[`${prop}${propAxis}Start`]) + parseFloat(styles[`${prop}${propAxis}End`]);\n}\n\n// src/utils/scroll-sides.ts\nfunction getScrollSides(node, dir) {\n  const scrollTop = node.scrollTop;\n  const scrollLeft = node.scrollLeft;\n  const isRtl = dir === \"rtl\";\n  const threshold = 1;\n  const hasVerticalScroll = node.scrollHeight - node.clientHeight > threshold;\n  const hasHorizontalScroll = node.scrollWidth - node.clientWidth > threshold;\n  const maxScrollLeft = node.scrollWidth - node.clientWidth;\n  const maxScrollTop = node.scrollHeight - node.clientHeight;\n  let atLeft = false;\n  let atRight = false;\n  let atTop = false;\n  let atBottom = false;\n  if (hasHorizontalScroll) {\n    if (isRtl) {\n      if (scrollLeft <= 0) {\n        atLeft = Math.abs(scrollLeft) >= maxScrollLeft - threshold;\n        atRight = Math.abs(scrollLeft) <= threshold;\n      } else {\n        atLeft = scrollLeft <= threshold;\n        atRight = scrollLeft >= maxScrollLeft - threshold;\n      }\n    } else {\n      atLeft = scrollLeft <= threshold;\n      atRight = scrollLeft >= maxScrollLeft - threshold;\n    }\n  }\n  if (hasVerticalScroll) {\n    atTop = scrollTop <= threshold;\n    atBottom = scrollTop >= maxScrollTop - threshold;\n  }\n  return {\n    top: atTop,\n    right: atRight,\n    bottom: atBottom,\n    left: atLeft\n  };\n}\n\n// src/utils/timeout.ts\nvar EMPTY = 0;\nvar Timeout = class {\n  constructor() {\n    __publicField(this, \"currentId\", EMPTY);\n    __publicField(this, \"clear\", () => {\n      if (this.currentId !== EMPTY) {\n        clearTimeout(this.currentId);\n        this.currentId = EMPTY;\n      }\n    });\n    __publicField(this, \"disposeEffect\", () => {\n      return this.clear;\n    });\n  }\n  start(delay, fn) {\n    this.clear();\n    this.currentId = setTimeout(() => {\n      this.currentId = EMPTY;\n      fn();\n    }, delay);\n  }\n  isStarted() {\n    return this.currentId !== EMPTY;\n  }\n};\n\n// src/scroll-area.machine.ts\nvar MIN_THUMB_SIZE = 20;\nvar SCROLL_TIMEOUT = 1e3;\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    ensureProps(props2, [\"id\"]);\n    return props2;\n  },\n  context({\n    bindable\n  }) {\n    return {\n      scrollingX: bindable(() => ({\n        defaultValue: false\n      })),\n      scrollingY: bindable(() => ({\n        defaultValue: false\n      })),\n      hovering: bindable(() => ({\n        defaultValue: false\n      })),\n      dragging: bindable(() => ({\n        defaultValue: false\n      })),\n      touchModality: bindable(() => ({\n        defaultValue: false\n      })),\n      atSides: bindable(() => ({\n        defaultValue: {\n          top: true,\n          right: false,\n          bottom: false,\n          left: true\n        }\n      })),\n      cornerSize: bindable(() => ({\n        defaultValue: {\n          width: 0,\n          height: 0\n        }\n      })),\n      thumbSize: bindable(() => ({\n        defaultValue: {\n          width: 0,\n          height: 0\n        }\n      })),\n      hiddenState: bindable(() => ({\n        defaultValue: {\n          scrollbarYHidden: false,\n          scrollbarXHidden: false,\n          cornerHidden: false\n        },\n        hash(a) {\n          return `Y:${a.scrollbarYHidden} X:${a.scrollbarXHidden} C:${a.cornerHidden}`;\n        }\n      }))\n    };\n  },\n  refs() {\n    return {\n      orientation: \"vertical\",\n      scrollPosition: {\n        x: 0,\n        y: 0\n      },\n      scrollYTimeout: new Timeout(),\n      scrollXTimeout: new Timeout(),\n      scrollEndTimeout: new Timeout(),\n      startX: 0,\n      startY: 0,\n      startScrollTop: 0,\n      startScrollLeft: 0,\n      programmaticScroll: true\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  watch({\n    track,\n    prop,\n    context,\n    send\n  }) {\n    track([() => prop(\"dir\"), () => context.hash(\"hiddenState\")], () => {\n      send({\n        type: \"thumb.measure\"\n      });\n    });\n  },\n  effects: [\"trackContentResize\", \"trackViewportVisibility\", \"trackWheelEvent\"],\n  entry: [\"checkHovering\"],\n  exit: [\"clearTimeouts\"],\n  on: {\n    \"thumb.measure\": {\n      actions: [\"setThumbSize\"]\n    },\n    \"viewport.scroll\": {\n      actions: [\"setThumbSize\", \"setScrolling\", \"setProgrammaticScroll\"]\n    },\n    \"root.pointerenter\": {\n      actions: [\"setTouchModality\", \"setHovering\"]\n    },\n    \"root.pointerdown\": {\n      actions: [\"setTouchModality\"]\n    },\n    \"root.pointerleave\": {\n      actions: [\"clearHovering\"]\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        \"scrollbar.pointerdown\": {\n          target: \"dragging\",\n          actions: [\"scrollToPointer\", \"startDragging\"]\n        },\n        \"thumb.pointerdown\": {\n          target: \"dragging\",\n          actions: [\"startDragging\"]\n        }\n      }\n    },\n    dragging: {\n      effects: [\"trackPointerMove\"],\n      on: {\n        \"thumb.pointermove\": {\n          actions: [\"setDraggingScroll\"]\n        },\n        \"scrollbar.pointerup\": {\n          target: \"idle\",\n          actions: [\"stopDragging\"]\n        },\n        \"thumb.pointerup\": {\n          target: \"idle\",\n          actions: [\"clearScrolling\", \"stopDragging\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    actions: {\n      setTouchModality({\n        context,\n        event\n      }) {\n        context.set(\"touchModality\", event.pointerType === \"touch\");\n      },\n      setHovering({\n        context\n      }) {\n        context.set(\"hovering\", true);\n      },\n      clearHovering({\n        context\n      }) {\n        context.set(\"hovering\", false);\n      },\n      setProgrammaticScroll({\n        refs\n      }) {\n        const scrollEndTimeout = refs.get(\"scrollEndTimeout\");\n        scrollEndTimeout.start(100, () => {\n          refs.set(\"programmaticScroll\", true);\n        });\n      },\n      clearScrolling({\n        context,\n        event\n      }) {\n        context.set(event.orientation === \"vertical\" ? \"scrollingY\" : \"scrollingX\", false);\n      },\n      setThumbSize({\n        context,\n        scope,\n        prop\n      }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const scrollableContentHeight = viewportEl.scrollHeight;\n        const scrollableContentWidth = viewportEl.scrollWidth;\n        if (scrollableContentHeight === 0 || scrollableContentWidth === 0) return;\n        const scrollbarYEl = getScrollbarYEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        const thumbYEl = getThumbYEl(scope);\n        const thumbXEl = getThumbXEl(scope);\n        const viewportHeight = viewportEl.clientHeight;\n        const viewportWidth = viewportEl.clientWidth;\n        const scrollTop = viewportEl.scrollTop;\n        const scrollLeft = viewportEl.scrollLeft;\n        const scrollbarYHidden = viewportHeight >= scrollableContentHeight;\n        const scrollbarXHidden = viewportWidth >= scrollableContentWidth;\n        const ratioX = viewportWidth / scrollableContentWidth;\n        const ratioY = viewportHeight / scrollableContentHeight;\n        const nextWidth = scrollbarXHidden ? 0 : viewportWidth;\n        const nextHeight = scrollbarYHidden ? 0 : viewportHeight;\n        const scrollbarXOffset = getScrollOffset(scrollbarXEl, \"padding\", \"x\");\n        const scrollbarYOffset = getScrollOffset(scrollbarYEl, \"padding\", \"y\");\n        const thumbXOffset = getScrollOffset(thumbXEl, \"margin\", \"x\");\n        const thumbYOffset = getScrollOffset(thumbYEl, \"margin\", \"y\");\n        const idealNextWidth = nextWidth - scrollbarXOffset - thumbXOffset;\n        const idealNextHeight = nextHeight - scrollbarYOffset - thumbYOffset;\n        const maxNextWidth = scrollbarXEl ? Math.min(scrollbarXEl.offsetWidth, idealNextWidth) : idealNextWidth;\n        const maxNextHeight = scrollbarYEl ? Math.min(scrollbarYEl.offsetHeight, idealNextHeight) : idealNextHeight;\n        const clampedNextWidth = Math.max(MIN_THUMB_SIZE, maxNextWidth * ratioX);\n        const clampedNextHeight = Math.max(MIN_THUMB_SIZE, maxNextHeight * ratioY);\n        context.set(\"thumbSize\", prevSize => {\n          if (prevSize.height === clampedNextHeight && prevSize.width === clampedNextWidth) {\n            return prevSize;\n          }\n          return {\n            width: clampedNextWidth,\n            height: clampedNextHeight\n          };\n        });\n        if (scrollbarYEl && thumbYEl) {\n          const maxThumbOffsetY = scrollbarYEl.offsetHeight - clampedNextHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = scrollTop / (scrollableContentHeight - viewportHeight);\n          const thumbOffsetY = Math.min(maxThumbOffsetY, Math.max(0, scrollRatioY * maxThumbOffsetY));\n          thumbYEl.style.transform = `translate3d(0,${thumbOffsetY}px,0)`;\n        }\n        if (scrollbarXEl && thumbXEl) {\n          const maxThumbOffsetX = scrollbarXEl.offsetWidth - clampedNextWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = scrollLeft / (scrollableContentWidth - viewportWidth);\n          const thumbOffsetX = prop(\"dir\") === \"rtl\" ? clampValue(scrollRatioX * maxThumbOffsetX, -maxThumbOffsetX, 0) : clampValue(scrollRatioX * maxThumbOffsetX, 0, maxThumbOffsetX);\n          thumbXEl.style.transform = `translate3d(${thumbOffsetX}px,0,0)`;\n        }\n        const cornerEl = getCornerEl(scope);\n        if (cornerEl) {\n          if (scrollbarXHidden || scrollbarYHidden) {\n            context.set(\"cornerSize\", {\n              width: 0,\n              height: 0\n            });\n          } else if (!scrollbarXHidden && !scrollbarYHidden) {\n            const width = scrollbarYEl?.offsetWidth || 0;\n            const height = scrollbarXEl?.offsetHeight || 0;\n            context.set(\"cornerSize\", {\n              width,\n              height\n            });\n          }\n        }\n        context.set(\"hiddenState\", prevState => {\n          const cornerHidden = scrollbarYHidden || scrollbarXHidden;\n          if (prevState.scrollbarYHidden === scrollbarYHidden && prevState.scrollbarXHidden === scrollbarXHidden && prevState.cornerHidden === cornerHidden) {\n            return prevState;\n          }\n          return {\n            scrollbarYHidden,\n            scrollbarXHidden,\n            cornerHidden\n          };\n        });\n        context.set(\"atSides\", prev => {\n          const next = getScrollSides(viewportEl, prop(\"dir\"));\n          if (isEqual(prev, next)) return prev;\n          return next;\n        });\n      },\n      checkHovering({\n        scope,\n        context\n      }) {\n        const viewportEl = getViewportEl(scope);\n        if (viewportEl?.matches(\":hover\")) {\n          context.set(\"hovering\", true);\n        }\n      },\n      setScrolling({\n        event,\n        refs,\n        context,\n        prop\n      }) {\n        const scrollPosition = {\n          x: event.target.scrollLeft,\n          y: event.target.scrollTop\n        };\n        const scrollPositionRef = refs.get(\"scrollPosition\");\n        const offsetX = scrollPosition.x - scrollPositionRef.x;\n        const offsetY = scrollPosition.y - scrollPositionRef.y;\n        refs.set(\"scrollPosition\", scrollPosition);\n        context.set(\"atSides\", prev => {\n          const next = getScrollSides(event.target, prop(\"dir\"));\n          if (isEqual(prev, next)) return prev;\n          return next;\n        });\n        if (offsetY !== 0) {\n          context.set(\"scrollingY\", true);\n          refs.get(\"scrollYTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingY\", false);\n          });\n        }\n        if (offsetX !== 0) {\n          context.set(\"scrollingX\", true);\n          refs.get(\"scrollXTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingX\", false);\n          });\n        }\n      },\n      scrollToPointer({\n        event,\n        scope,\n        prop\n      }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const thumbYRef = getThumbYEl(scope);\n        const scrollbarYRef = getScrollbarYEl(scope);\n        const thumbXRef = getThumbXEl(scope);\n        const scrollbarXRef = getScrollbarXEl(scope);\n        const client = event.point;\n        if (thumbYRef && scrollbarYRef && event.orientation === \"vertical\") {\n          const thumbYOffset = getScrollOffset(thumbYRef, \"margin\", \"y\");\n          const scrollbarYOffset = getScrollOffset(scrollbarYRef, \"padding\", \"y\");\n          const thumbHeight = thumbYRef.offsetHeight;\n          const trackRectY = scrollbarYRef.getBoundingClientRect();\n          const clickY = client.y - trackRectY.top - thumbHeight / 2 - scrollbarYOffset + thumbYOffset / 2;\n          const scrollableContentHeight = viewportEl.scrollHeight;\n          const viewportHeight = viewportEl.clientHeight;\n          const maxThumbOffsetY = scrollbarYRef.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = clickY / maxThumbOffsetY;\n          const newScrollTop = scrollRatioY * (scrollableContentHeight - viewportHeight);\n          viewportEl.scrollTop = newScrollTop;\n        }\n        if (thumbXRef && scrollbarXRef && event.orientation === \"horizontal\") {\n          const thumbXOffset = getScrollOffset(thumbXRef, \"margin\", \"x\");\n          const scrollbarXOffset = getScrollOffset(scrollbarXRef, \"padding\", \"x\");\n          const thumbWidth = thumbXRef.offsetWidth;\n          const trackRectX = scrollbarXRef.getBoundingClientRect();\n          const clickX = client.x - trackRectX.left - thumbWidth / 2 - scrollbarXOffset + thumbXOffset / 2;\n          const scrollableContentWidth = viewportEl.scrollWidth;\n          const viewportWidth = viewportEl.clientWidth;\n          const maxThumbOffsetX = scrollbarXRef.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = clickX / maxThumbOffsetX;\n          let newScrollLeft;\n          if (prop(\"dir\") === \"rtl\") {\n            newScrollLeft = (1 - scrollRatioX) * (scrollableContentWidth - viewportWidth);\n            if (viewportEl.scrollLeft <= 0) {\n              newScrollLeft = -newScrollLeft;\n            }\n          } else {\n            newScrollLeft = scrollRatioX * (scrollableContentWidth - viewportWidth);\n          }\n          viewportEl.scrollLeft = newScrollLeft;\n        }\n      },\n      startDragging({\n        event,\n        refs,\n        scope\n      }) {\n        refs.set(\"startX\", event.point.x);\n        refs.set(\"startY\", event.point.y);\n        refs.set(\"orientation\", event.orientation);\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        refs.set(\"startScrollTop\", viewportEl.scrollTop);\n        refs.set(\"startScrollLeft\", viewportEl.scrollLeft);\n      },\n      setDraggingScroll({\n        event,\n        refs,\n        scope,\n        context\n      }) {\n        const startY = refs.get(\"startY\");\n        const startX = refs.get(\"startX\");\n        const startScrollTop = refs.get(\"startScrollTop\");\n        const startScrollLeft = refs.get(\"startScrollLeft\");\n        const client = event.point;\n        const deltaY = client.y - startY;\n        const deltaX = client.x - startX;\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const scrollableContentHeight = viewportEl.scrollHeight;\n        const viewportHeight = viewportEl.clientHeight;\n        const scrollableContentWidth = viewportEl.scrollWidth;\n        const viewportWidth = viewportEl.clientWidth;\n        const orientation = refs.get(\"orientation\");\n        const thumbYEl = getThumbYEl(scope);\n        const scrollbarYEl = getScrollbarYEl(scope);\n        if (thumbYEl && scrollbarYEl && orientation === \"vertical\") {\n          const scrollbarYOffset = getScrollOffset(scrollbarYEl, \"padding\", \"y\");\n          const thumbYOffset = getScrollOffset(thumbYEl, \"margin\", \"y\");\n          const thumbHeight = thumbYEl.offsetHeight;\n          const maxThumbOffsetY = scrollbarYEl.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = deltaY / maxThumbOffsetY;\n          viewportEl.scrollTop = startScrollTop + scrollRatioY * (scrollableContentHeight - viewportHeight);\n          context.set(\"scrollingY\", true);\n          refs.get(\"scrollYTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingY\", false);\n          });\n        }\n        const thumbXEl = getThumbXEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        if (thumbXEl && scrollbarXEl && orientation === \"horizontal\") {\n          const scrollbarXOffset = getScrollOffset(scrollbarXEl, \"padding\", \"x\");\n          const thumbXOffset = getScrollOffset(thumbXEl, \"margin\", \"x\");\n          const thumbWidth = thumbXEl.offsetWidth;\n          const maxThumbOffsetX = scrollbarXEl.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = deltaX / maxThumbOffsetX;\n          viewportEl.scrollLeft = startScrollLeft + scrollRatioX * (scrollableContentWidth - viewportWidth);\n          context.set(\"scrollingX\", true);\n          refs.get(\"scrollXTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingX\", false);\n          });\n        }\n      },\n      stopDragging({\n        refs\n      }) {\n        refs.set(\"orientation\", null);\n      },\n      clearTimeouts({\n        refs\n      }) {\n        refs.get(\"scrollYTimeout\").clear();\n        refs.get(\"scrollXTimeout\").clear();\n        refs.get(\"scrollEndTimeout\").clear();\n      }\n    },\n    effects: {\n      trackContentResize({\n        scope,\n        send\n      }) {\n        const contentEl = getContentEl(scope);\n        const rootEl = getRootEl(scope);\n        if (!contentEl || !rootEl) return;\n        const win = scope.getWin();\n        const obs = new win.ResizeObserver(() => {\n          setTimeout(() => {\n            send({\n              type: \"thumb.measure\"\n            });\n          }, 1);\n        });\n        obs.observe(contentEl);\n        obs.observe(rootEl);\n        return () => {\n          obs.disconnect();\n        };\n      },\n      trackViewportVisibility({\n        scope,\n        send\n      }) {\n        const win = scope.getWin();\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const observer = new win.IntersectionObserver(entries => {\n          entries.forEach(entry => {\n            if (entry.intersectionRatio > 0) {\n              send({\n                type: \"thumb.measure\"\n              });\n              observer.disconnect();\n            }\n          });\n        });\n        observer.observe(viewportEl);\n        return () => {\n          observer.disconnect();\n        };\n      },\n      trackWheelEvent({\n        scope\n      }) {\n        const scrollbarYEl = getScrollbarYEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        if (!scrollbarYEl && !scrollbarXEl) return;\n        const onWheel = event => {\n          const viewportEl = getViewportEl(scope);\n          if (!viewportEl || event.ctrlKey) return;\n          const orientation = event.currentTarget.dataset.orientation;\n          if (orientation === \"vertical\") {\n            const canScrollY = viewportEl.scrollHeight > viewportEl.clientHeight;\n            const atTop = viewportEl.scrollTop === 0 && event.deltaY < 0;\n            const atBottom = viewportEl.scrollTop === viewportEl.scrollHeight - viewportEl.clientHeight && event.deltaY > 0;\n            const shouldScroll = canScrollY && event.deltaY !== 0 && !(atTop || atBottom);\n            if (!shouldScroll) return;\n            event.preventDefault();\n            viewportEl.scrollTop += event.deltaY;\n          } else if (orientation === \"horizontal\") {\n            const canScrollX = viewportEl.scrollWidth > viewportEl.clientWidth;\n            const atLeft = viewportEl.scrollLeft === 0 && event.deltaX < 0;\n            const atRight = viewportEl.scrollLeft === viewportEl.scrollWidth - viewportEl.clientWidth && event.deltaX > 0;\n            const shouldScroll = canScrollX && event.deltaX !== 0 && !(atLeft || atRight);\n            if (!shouldScroll) return;\n            event.preventDefault();\n            viewportEl.scrollLeft += event.deltaX;\n          }\n        };\n        return callAll(scrollbarYEl && addDomEvent(scrollbarYEl, \"wheel\", onWheel, {\n          passive: false\n        }), scrollbarXEl && addDomEvent(scrollbarXEl, \"wheel\", onWheel, {\n          passive: false\n        }));\n      },\n      trackPointerMove({\n        scope,\n        send,\n        refs\n      }) {\n        const doc = scope.getDoc();\n        const orientation = refs.get(\"orientation\");\n        return trackPointerMove(doc, {\n          onPointerMove({\n            point\n          }) {\n            send({\n              type: \"thumb.pointermove\",\n              orientation,\n              point\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"thumb.pointerup\",\n              orientation\n            });\n          }\n        });\n      }\n    }\n  }\n});\nvar props = createProps()([\"dir\", \"getRootNode\", \"ids\", \"id\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":{"version":3,"names":["createAnatomy","trackPointerMove","query","addDomEvent","getComputedStyle","dataAttr","getEventPoint","contains","getEventTarget","callAll","isEqual","clampValue","ensureProps","createSplitProps","toPx","compact","createMachine","createProps","__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","anatomy","parts","build","getRootId","ctx","ids","root","id","getViewportId","viewport","getContentId","content","getRootEl","getById","getViewportEl","getContentEl","getScrollbarXEl","getScrollbarYEl","getThumbXEl","getThumbYEl","getCornerEl","getScrollProgress","element","scrollThreshold","EMPTY_SCROLL_PROGRESS","progressX","progressY","maxScrollX","scrollWidth","clientWidth","Math","min","max","scrollLeft","maxScrollY","scrollHeight","clientHeight","scrollTop","x","y","DURATION","EASE_OUT_QUAD","t","smoothScroll","node","options","top","left","duration","easing","onComplete","state","startTime","startScrollTop","startScrollLeft","targetScrollTop","targetScrollLeft","cancelled","cleanup","rafId","cancelAnimationFrame","animate","currentTime","elapsed","progress","easedProgress","deltaTop","deltaLeft","requestAnimationFrame","scrollTo","behavior","scrollOptions","scrollToEdge","edge","dir","maxLeft","maxTop","isRtl","negative","connect","service","normalize","send","context","prop","scope","dragging","matches","hovering","get","cornerSize","thumbSize","hiddenState","atSides","isAtTop","isAtBottom","bottom","isAtLeft","isAtRight","right","hasOverflowX","scrollbarXHidden","hasOverflowY","scrollbarYHidden","details","getScrollbarState","props2","horizontal","orientation","scrolling","hidden","getRootProps","attrs","role","onPointerEnter","event","target","currentTarget","type","pointerType","onPointerMove","onPointerDown","onPointerLeave","relatedTarget","style","position","width","height","getViewportProps","handleUserInteraction","tabIndex","overflow","onScroll","onWheel","onTouchMove","onKeyDown","getContentProps","minWidth","getScrollbarProps","scrollbar","onPointerUp","button","point","stopPropagation","touchAction","WebkitUserSelect","userSelect","insetInlineEnd","insetInlineStart","getThumbProps","thumb","getCornerProps","corner","cornerHidden","getScrollOffset","axis","styles","propAxis","parseFloat","getScrollSides","threshold","hasVerticalScroll","hasHorizontalScroll","maxScrollLeft","maxScrollTop","atLeft","atRight","atTop","atBottom","abs","EMPTY","Timeout","constructor","currentId","clearTimeout","clear","start","delay","fn","setTimeout","isStarted","MIN_THUMB_SIZE","SCROLL_TIMEOUT","machine","props","bindable","scrollingX","defaultValue","scrollingY","touchModality","hash","a","refs","scrollPosition","scrollYTimeout","scrollXTimeout","scrollEndTimeout","startX","startY","programmaticScroll","initialState","watch","track","effects","entry","exit","on","actions","states","idle","implementations","setTouchModality","set","setHovering","clearHovering","setProgrammaticScroll","clearScrolling","setThumbSize","viewportEl","scrollableContentHeight","scrollableContentWidth","scrollbarYEl","scrollbarXEl","thumbYEl","thumbXEl","viewportHeight","viewportWidth","ratioX","ratioY","nextWidth","nextHeight","scrollbarXOffset","scrollbarYOffset","thumbXOffset","thumbYOffset","idealNextWidth","idealNextHeight","maxNextWidth","offsetWidth","maxNextHeight","offsetHeight","clampedNextWidth","clampedNextHeight","prevSize","maxThumbOffsetY","scrollRatioY","thumbOffsetY","transform","maxThumbOffsetX","scrollRatioX","thumbOffsetX","cornerEl","prevState","prev","next","checkHovering","setScrolling","scrollPositionRef","offsetX","offsetY","scrollToPointer","thumbYRef","scrollbarYRef","thumbXRef","scrollbarXRef","client","thumbHeight","trackRectY","getBoundingClientRect","clickY","newScrollTop","thumbWidth","trackRectX","clickX","newScrollLeft","startDragging","setDraggingScroll","deltaY","deltaX","stopDragging","clearTimeouts","trackContentResize","contentEl","rootEl","win","getWin","obs","ResizeObserver","observe","disconnect","trackViewportVisibility","observer","IntersectionObserver","entries","forEach","intersectionRatio","trackWheelEvent","ctrlKey","dataset","canScrollY","shouldScroll","preventDefault","canScrollX","passive","doc","getDoc","splitProps"],"sources":["/Users/ameliamagick/personal-finance-tracker/node_modules/@zag-js/scroll-area/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, query, addDomEvent, getComputedStyle, dataAttr, getEventPoint, contains, getEventTarget } from '@zag-js/dom-query';\nimport { callAll, isEqual, clampValue, ensureProps, createSplitProps, toPx, compact } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar anatomy = createAnatomy(\"scroll-area\").parts(\"root\", \"viewport\", \"content\", \"scrollbar\", \"thumb\", \"corner\");\nvar parts = anatomy.build();\nvar getRootId = (ctx) => ctx.ids?.root ?? `scroll-area-${ctx.id}`;\nvar getViewportId = (ctx) => ctx.ids?.viewport ?? `scroll-area-${ctx.id}:viewport`;\nvar getContentId = (ctx) => ctx.ids?.content ?? `scroll-area-${ctx.id}:content`;\nvar getRootEl = (ctx) => ctx.getById(getRootId(ctx));\nvar getViewportEl = (ctx) => ctx.getById(getViewportId(ctx));\nvar getContentEl = (ctx) => ctx.getById(getContentId(ctx));\nvar getScrollbarXEl = (ctx) => query(getRootEl(ctx), `[data-part=scrollbar][data-orientation=horizontal][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getScrollbarYEl = (ctx) => query(getRootEl(ctx), `[data-part=scrollbar][data-orientation=vertical][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getThumbXEl = (ctx) => query(getScrollbarXEl(ctx), `[data-part=thumb][data-orientation=horizontal][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getThumbYEl = (ctx) => query(getScrollbarYEl(ctx), `[data-part=thumb][data-orientation=vertical][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getCornerEl = (ctx) => query(getRootEl(ctx), `[data-part=corner][data-ownedby=\"${getRootId(ctx)}\"]`);\n\n// src/utils/scroll-progress.ts\nfunction getScrollProgress(element, scrollThreshold) {\n  if (!element) return EMPTY_SCROLL_PROGRESS;\n  let progressX = 0;\n  let progressY = 0;\n  const maxScrollX = element.scrollWidth - element.clientWidth;\n  if (maxScrollX > scrollThreshold) {\n    progressX = Math.min(1, Math.max(0, element.scrollLeft / maxScrollX));\n  }\n  const maxScrollY = element.scrollHeight - element.clientHeight;\n  if (maxScrollY > scrollThreshold) {\n    progressY = Math.min(1, Math.max(0, element.scrollTop / maxScrollY));\n  }\n  return { x: progressX, y: progressY };\n}\nvar EMPTY_SCROLL_PROGRESS = { x: 0, y: 0 };\n\n// src/utils/smooth-scroll.ts\nvar DURATION = 300;\nvar EASE_OUT_QUAD = (t) => t * (2 - t);\nfunction smoothScroll(node, options = {}) {\n  const { top, left, duration = DURATION, easing = EASE_OUT_QUAD, onComplete } = options;\n  if (!node) return;\n  const state = {\n    startTime: 0,\n    startScrollTop: node.scrollTop,\n    startScrollLeft: node.scrollLeft,\n    targetScrollTop: top ?? node.scrollTop,\n    targetScrollLeft: left ?? node.scrollLeft\n  };\n  let cancelled = false;\n  const cleanup = () => {\n    if (state.rafId) {\n      cancelAnimationFrame(state.rafId);\n      state.rafId = void 0;\n    }\n    cancelled = true;\n  };\n  const animate = (currentTime) => {\n    if (cancelled) return;\n    if (state.startTime === 0) {\n      state.startTime = currentTime;\n    }\n    const elapsed = currentTime - state.startTime;\n    const progress = Math.min(elapsed / duration, 1);\n    const easedProgress = easing(progress);\n    const deltaTop = state.targetScrollTop - state.startScrollTop;\n    const deltaLeft = state.targetScrollLeft - state.startScrollLeft;\n    node.scrollTop = state.startScrollTop + deltaTop * easedProgress;\n    node.scrollLeft = state.startScrollLeft + deltaLeft * easedProgress;\n    if (progress < 1) {\n      state.rafId = requestAnimationFrame(animate);\n    } else {\n      onComplete?.();\n    }\n  };\n  state.rafId = requestAnimationFrame(animate);\n  return cleanup;\n}\n\n// src/utils/scroll-to.ts\nfunction scrollTo(node, options = {}) {\n  if (!node) return;\n  const { top, left, behavior = \"smooth\", easing, duration } = options;\n  if (behavior === \"smooth\") {\n    smoothScroll(node, { top, left, easing, duration });\n  } else {\n    const scrollOptions = compact({ behavior, top, left });\n    node.scrollTo(scrollOptions);\n  }\n}\nfunction scrollToEdge(node, edge, dir, behavior = \"smooth\", easing, duration) {\n  if (!node) return;\n  const maxLeft = node.scrollWidth - node.clientWidth;\n  const maxTop = node.scrollHeight - node.clientHeight;\n  const isRtl = dir === \"rtl\";\n  let targetScrollTop;\n  let targetScrollLeft;\n  switch (edge) {\n    case \"top\":\n      targetScrollTop = 0;\n      break;\n    case \"bottom\":\n      targetScrollTop = maxTop;\n      break;\n    case \"left\":\n      if (isRtl) {\n        const negative = node.scrollLeft <= 0;\n        targetScrollLeft = negative ? -maxLeft : 0;\n      } else {\n        targetScrollLeft = 0;\n      }\n      break;\n    case \"right\":\n      if (isRtl) {\n        const negative = node.scrollLeft <= 0;\n        targetScrollLeft = negative ? 0 : maxLeft;\n      } else {\n        targetScrollLeft = maxLeft;\n      }\n      break;\n  }\n  if (behavior === \"smooth\") {\n    smoothScroll(node, { top: targetScrollTop, left: targetScrollLeft, easing, duration });\n  } else {\n    const options = compact({ left: targetScrollLeft, top: targetScrollTop, behavior });\n    node.scrollTo(options);\n  }\n}\n\n// src/scroll-area.connect.ts\nfunction connect(service, normalize) {\n  const { state, send, context, prop, scope } = service;\n  const dragging = state.matches(\"dragging\");\n  const hovering = context.get(\"hovering\");\n  const cornerSize = context.get(\"cornerSize\");\n  const thumbSize = context.get(\"thumbSize\");\n  const hiddenState = context.get(\"hiddenState\");\n  const atSides = context.get(\"atSides\");\n  return {\n    isAtTop: atSides.top,\n    isAtBottom: atSides.bottom,\n    isAtLeft: atSides.left,\n    isAtRight: atSides.right,\n    hasOverflowX: !hiddenState.scrollbarXHidden,\n    hasOverflowY: !hiddenState.scrollbarYHidden,\n    getScrollProgress() {\n      return getScrollProgress(getViewportEl(scope), 0);\n    },\n    scrollToEdge(details) {\n      const { edge, behavior } = details;\n      return scrollToEdge(getViewportEl(scope), edge, prop(\"dir\"), behavior);\n    },\n    scrollTo(details) {\n      return scrollTo(getViewportEl(scope), details);\n    },\n    getScrollbarState(props2) {\n      const horizontal = props2.orientation === \"horizontal\";\n      return {\n        hovering,\n        dragging,\n        scrolling: context.get(horizontal ? \"scrollingX\" : \"scrollingY\"),\n        hidden: horizontal ? hiddenState.scrollbarXHidden : hiddenState.scrollbarYHidden\n      };\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        role: \"presentation\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        onPointerEnter(event) {\n          const target = getEventTarget(event);\n          if (!contains(event.currentTarget, target)) return;\n          send({ type: \"root.pointerenter\", pointerType: event.pointerType });\n        },\n        onPointerMove(event) {\n          const target = getEventTarget(event);\n          if (!contains(event.currentTarget, target)) return;\n          send({ type: \"root.pointerenter\", pointerType: event.pointerType });\n        },\n        onPointerDown({ pointerType }) {\n          send({ type: \"root.pointerdown\", pointerType });\n        },\n        onPointerLeave(event) {\n          if (contains(event.currentTarget, event.relatedTarget)) return;\n          send({ type: \"root.pointerleave\" });\n        },\n        style: {\n          position: \"relative\",\n          \"--corner-width\": toPx(cornerSize?.width),\n          \"--corner-height\": toPx(cornerSize?.height),\n          \"--thumb-width\": toPx(thumbSize?.width),\n          \"--thumb-height\": toPx(thumbSize?.height)\n        }\n      });\n    },\n    getViewportProps() {\n      const handleUserInteraction = () => {\n        send({ type: \"user.scroll\" });\n      };\n      return normalize.element({\n        ...parts.viewport.attrs,\n        role: \"presentation\",\n        \"data-ownedby\": getRootId(scope),\n        id: getViewportId(scope),\n        \"data-at-top\": dataAttr(atSides.top),\n        \"data-at-bottom\": dataAttr(atSides.bottom),\n        \"data-at-left\": dataAttr(atSides.left),\n        \"data-at-right\": dataAttr(atSides.right),\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        tabIndex: hiddenState.scrollbarXHidden || hiddenState.scrollbarYHidden ? void 0 : 0,\n        style: {\n          overflow: \"auto\"\n        },\n        onScroll(event) {\n          send({ type: \"viewport.scroll\", target: event.currentTarget });\n        },\n        onWheel: handleUserInteraction,\n        onTouchMove: handleUserInteraction,\n        onPointerMove: handleUserInteraction,\n        onPointerEnter: handleUserInteraction,\n        onKeyDown: handleUserInteraction\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        id: getContentId(scope),\n        role: \"presentation\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        style: {\n          minWidth: \"fit-content\"\n        }\n      });\n    },\n    getScrollbarProps(props2 = {}) {\n      const { orientation = \"vertical\" } = props2;\n      return normalize.element({\n        ...parts.scrollbar.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-orientation\": orientation,\n        \"data-scrolling\": dataAttr(context.get(orientation === \"horizontal\" ? \"scrollingX\" : \"scrollingY\")),\n        \"data-hover\": dataAttr(hovering),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        onPointerUp() {\n          send({ type: \"scrollbar.pointerup\", orientation });\n        },\n        onPointerDown(event) {\n          if (event.button !== 0) {\n            return;\n          }\n          if (event.currentTarget !== event.target) {\n            return;\n          }\n          const point = getEventPoint(event);\n          send({ type: \"scrollbar.pointerdown\", orientation, point });\n          event.stopPropagation();\n        },\n        style: {\n          position: \"absolute\",\n          touchAction: \"none\",\n          WebkitUserSelect: \"none\",\n          userSelect: \"none\",\n          ...orientation === \"vertical\" && {\n            top: 0,\n            bottom: `var(--corner-height)`,\n            insetInlineEnd: 0\n          },\n          ...orientation === \"horizontal\" && {\n            insetInlineStart: 0,\n            insetInlineEnd: `var(--corner-width)`,\n            bottom: 0\n          }\n        }\n      });\n    },\n    getThumbProps(props2 = {}) {\n      const { orientation = \"vertical\" } = props2;\n      return normalize.element({\n        ...parts.thumb.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-orientation\": orientation,\n        \"data-hover\": dataAttr(hovering),\n        \"data-dragging\": dataAttr(dragging),\n        onPointerDown(event) {\n          if (event.button !== 0) return;\n          const point = getEventPoint(event);\n          send({ type: \"thumb.pointerdown\", orientation, point });\n        },\n        style: {\n          ...orientation === \"vertical\" && {\n            height: \"var(--thumb-height)\"\n          },\n          ...orientation === \"horizontal\" && {\n            width: \"var(--thumb-width)\"\n          }\n        }\n      });\n    },\n    getCornerProps() {\n      return normalize.element({\n        ...parts.corner.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-hover\": dataAttr(hovering),\n        \"data-state\": hiddenState.cornerHidden ? \"hidden\" : \"visible\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        style: {\n          position: \"absolute\",\n          bottom: 0,\n          insetInlineEnd: 0,\n          width: \"var(--corner-width)\",\n          height: \"var(--corner-height)\"\n        }\n      });\n    }\n  };\n}\nfunction getScrollOffset(element, prop, axis) {\n  if (!element) return 0;\n  const styles = getComputedStyle(element);\n  const propAxis = axis === \"x\" ? \"Inline\" : \"Block\";\n  if (axis === \"x\" && prop === \"margin\") {\n    return parseFloat(styles[`${prop}InlineStart`]) * 2;\n  }\n  return parseFloat(styles[`${prop}${propAxis}Start`]) + parseFloat(styles[`${prop}${propAxis}End`]);\n}\n\n// src/utils/scroll-sides.ts\nfunction getScrollSides(node, dir) {\n  const scrollTop = node.scrollTop;\n  const scrollLeft = node.scrollLeft;\n  const isRtl = dir === \"rtl\";\n  const threshold = 1;\n  const hasVerticalScroll = node.scrollHeight - node.clientHeight > threshold;\n  const hasHorizontalScroll = node.scrollWidth - node.clientWidth > threshold;\n  const maxScrollLeft = node.scrollWidth - node.clientWidth;\n  const maxScrollTop = node.scrollHeight - node.clientHeight;\n  let atLeft = false;\n  let atRight = false;\n  let atTop = false;\n  let atBottom = false;\n  if (hasHorizontalScroll) {\n    if (isRtl) {\n      if (scrollLeft <= 0) {\n        atLeft = Math.abs(scrollLeft) >= maxScrollLeft - threshold;\n        atRight = Math.abs(scrollLeft) <= threshold;\n      } else {\n        atLeft = scrollLeft <= threshold;\n        atRight = scrollLeft >= maxScrollLeft - threshold;\n      }\n    } else {\n      atLeft = scrollLeft <= threshold;\n      atRight = scrollLeft >= maxScrollLeft - threshold;\n    }\n  }\n  if (hasVerticalScroll) {\n    atTop = scrollTop <= threshold;\n    atBottom = scrollTop >= maxScrollTop - threshold;\n  }\n  return {\n    top: atTop,\n    right: atRight,\n    bottom: atBottom,\n    left: atLeft\n  };\n}\n\n// src/utils/timeout.ts\nvar EMPTY = 0;\nvar Timeout = class {\n  constructor() {\n    __publicField(this, \"currentId\", EMPTY);\n    __publicField(this, \"clear\", () => {\n      if (this.currentId !== EMPTY) {\n        clearTimeout(this.currentId);\n        this.currentId = EMPTY;\n      }\n    });\n    __publicField(this, \"disposeEffect\", () => {\n      return this.clear;\n    });\n  }\n  start(delay, fn) {\n    this.clear();\n    this.currentId = setTimeout(() => {\n      this.currentId = EMPTY;\n      fn();\n    }, delay);\n  }\n  isStarted() {\n    return this.currentId !== EMPTY;\n  }\n};\n\n// src/scroll-area.machine.ts\nvar MIN_THUMB_SIZE = 20;\nvar SCROLL_TIMEOUT = 1e3;\nvar machine = createMachine({\n  props({ props: props2 }) {\n    ensureProps(props2, [\"id\"]);\n    return props2;\n  },\n  context({ bindable }) {\n    return {\n      scrollingX: bindable(() => ({ defaultValue: false })),\n      scrollingY: bindable(() => ({ defaultValue: false })),\n      hovering: bindable(() => ({ defaultValue: false })),\n      dragging: bindable(() => ({ defaultValue: false })),\n      touchModality: bindable(() => ({ defaultValue: false })),\n      atSides: bindable(() => ({\n        defaultValue: { top: true, right: false, bottom: false, left: true }\n      })),\n      cornerSize: bindable(() => ({\n        defaultValue: { width: 0, height: 0 }\n      })),\n      thumbSize: bindable(() => ({\n        defaultValue: { width: 0, height: 0 }\n      })),\n      hiddenState: bindable(() => ({\n        defaultValue: {\n          scrollbarYHidden: false,\n          scrollbarXHidden: false,\n          cornerHidden: false\n        },\n        hash(a) {\n          return `Y:${a.scrollbarYHidden} X:${a.scrollbarXHidden} C:${a.cornerHidden}`;\n        }\n      }))\n    };\n  },\n  refs() {\n    return {\n      orientation: \"vertical\",\n      scrollPosition: { x: 0, y: 0 },\n      scrollYTimeout: new Timeout(),\n      scrollXTimeout: new Timeout(),\n      scrollEndTimeout: new Timeout(),\n      startX: 0,\n      startY: 0,\n      startScrollTop: 0,\n      startScrollLeft: 0,\n      programmaticScroll: true\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  watch({ track, prop, context, send }) {\n    track([() => prop(\"dir\"), () => context.hash(\"hiddenState\")], () => {\n      send({ type: \"thumb.measure\" });\n    });\n  },\n  effects: [\"trackContentResize\", \"trackViewportVisibility\", \"trackWheelEvent\"],\n  entry: [\"checkHovering\"],\n  exit: [\"clearTimeouts\"],\n  on: {\n    \"thumb.measure\": {\n      actions: [\"setThumbSize\"]\n    },\n    \"viewport.scroll\": {\n      actions: [\"setThumbSize\", \"setScrolling\", \"setProgrammaticScroll\"]\n    },\n    \"root.pointerenter\": {\n      actions: [\"setTouchModality\", \"setHovering\"]\n    },\n    \"root.pointerdown\": {\n      actions: [\"setTouchModality\"]\n    },\n    \"root.pointerleave\": {\n      actions: [\"clearHovering\"]\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        \"scrollbar.pointerdown\": {\n          target: \"dragging\",\n          actions: [\"scrollToPointer\", \"startDragging\"]\n        },\n        \"thumb.pointerdown\": {\n          target: \"dragging\",\n          actions: [\"startDragging\"]\n        }\n      }\n    },\n    dragging: {\n      effects: [\"trackPointerMove\"],\n      on: {\n        \"thumb.pointermove\": {\n          actions: [\"setDraggingScroll\"]\n        },\n        \"scrollbar.pointerup\": {\n          target: \"idle\",\n          actions: [\"stopDragging\"]\n        },\n        \"thumb.pointerup\": {\n          target: \"idle\",\n          actions: [\"clearScrolling\", \"stopDragging\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    actions: {\n      setTouchModality({ context, event }) {\n        context.set(\"touchModality\", event.pointerType === \"touch\");\n      },\n      setHovering({ context }) {\n        context.set(\"hovering\", true);\n      },\n      clearHovering({ context }) {\n        context.set(\"hovering\", false);\n      },\n      setProgrammaticScroll({ refs }) {\n        const scrollEndTimeout = refs.get(\"scrollEndTimeout\");\n        scrollEndTimeout.start(100, () => {\n          refs.set(\"programmaticScroll\", true);\n        });\n      },\n      clearScrolling({ context, event }) {\n        context.set(event.orientation === \"vertical\" ? \"scrollingY\" : \"scrollingX\", false);\n      },\n      setThumbSize({ context, scope, prop }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const scrollableContentHeight = viewportEl.scrollHeight;\n        const scrollableContentWidth = viewportEl.scrollWidth;\n        if (scrollableContentHeight === 0 || scrollableContentWidth === 0) return;\n        const scrollbarYEl = getScrollbarYEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        const thumbYEl = getThumbYEl(scope);\n        const thumbXEl = getThumbXEl(scope);\n        const viewportHeight = viewportEl.clientHeight;\n        const viewportWidth = viewportEl.clientWidth;\n        const scrollTop = viewportEl.scrollTop;\n        const scrollLeft = viewportEl.scrollLeft;\n        const scrollbarYHidden = viewportHeight >= scrollableContentHeight;\n        const scrollbarXHidden = viewportWidth >= scrollableContentWidth;\n        const ratioX = viewportWidth / scrollableContentWidth;\n        const ratioY = viewportHeight / scrollableContentHeight;\n        const nextWidth = scrollbarXHidden ? 0 : viewportWidth;\n        const nextHeight = scrollbarYHidden ? 0 : viewportHeight;\n        const scrollbarXOffset = getScrollOffset(scrollbarXEl, \"padding\", \"x\");\n        const scrollbarYOffset = getScrollOffset(scrollbarYEl, \"padding\", \"y\");\n        const thumbXOffset = getScrollOffset(thumbXEl, \"margin\", \"x\");\n        const thumbYOffset = getScrollOffset(thumbYEl, \"margin\", \"y\");\n        const idealNextWidth = nextWidth - scrollbarXOffset - thumbXOffset;\n        const idealNextHeight = nextHeight - scrollbarYOffset - thumbYOffset;\n        const maxNextWidth = scrollbarXEl ? Math.min(scrollbarXEl.offsetWidth, idealNextWidth) : idealNextWidth;\n        const maxNextHeight = scrollbarYEl ? Math.min(scrollbarYEl.offsetHeight, idealNextHeight) : idealNextHeight;\n        const clampedNextWidth = Math.max(MIN_THUMB_SIZE, maxNextWidth * ratioX);\n        const clampedNextHeight = Math.max(MIN_THUMB_SIZE, maxNextHeight * ratioY);\n        context.set(\"thumbSize\", (prevSize) => {\n          if (prevSize.height === clampedNextHeight && prevSize.width === clampedNextWidth) {\n            return prevSize;\n          }\n          return {\n            width: clampedNextWidth,\n            height: clampedNextHeight\n          };\n        });\n        if (scrollbarYEl && thumbYEl) {\n          const maxThumbOffsetY = scrollbarYEl.offsetHeight - clampedNextHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = scrollTop / (scrollableContentHeight - viewportHeight);\n          const thumbOffsetY = Math.min(maxThumbOffsetY, Math.max(0, scrollRatioY * maxThumbOffsetY));\n          thumbYEl.style.transform = `translate3d(0,${thumbOffsetY}px,0)`;\n        }\n        if (scrollbarXEl && thumbXEl) {\n          const maxThumbOffsetX = scrollbarXEl.offsetWidth - clampedNextWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = scrollLeft / (scrollableContentWidth - viewportWidth);\n          const thumbOffsetX = prop(\"dir\") === \"rtl\" ? clampValue(scrollRatioX * maxThumbOffsetX, -maxThumbOffsetX, 0) : clampValue(scrollRatioX * maxThumbOffsetX, 0, maxThumbOffsetX);\n          thumbXEl.style.transform = `translate3d(${thumbOffsetX}px,0,0)`;\n        }\n        const cornerEl = getCornerEl(scope);\n        if (cornerEl) {\n          if (scrollbarXHidden || scrollbarYHidden) {\n            context.set(\"cornerSize\", { width: 0, height: 0 });\n          } else if (!scrollbarXHidden && !scrollbarYHidden) {\n            const width = scrollbarYEl?.offsetWidth || 0;\n            const height = scrollbarXEl?.offsetHeight || 0;\n            context.set(\"cornerSize\", { width, height });\n          }\n        }\n        context.set(\"hiddenState\", (prevState) => {\n          const cornerHidden = scrollbarYHidden || scrollbarXHidden;\n          if (prevState.scrollbarYHidden === scrollbarYHidden && prevState.scrollbarXHidden === scrollbarXHidden && prevState.cornerHidden === cornerHidden) {\n            return prevState;\n          }\n          return {\n            scrollbarYHidden,\n            scrollbarXHidden,\n            cornerHidden\n          };\n        });\n        context.set(\"atSides\", (prev) => {\n          const next = getScrollSides(viewportEl, prop(\"dir\"));\n          if (isEqual(prev, next)) return prev;\n          return next;\n        });\n      },\n      checkHovering({ scope, context }) {\n        const viewportEl = getViewportEl(scope);\n        if (viewportEl?.matches(\":hover\")) {\n          context.set(\"hovering\", true);\n        }\n      },\n      setScrolling({ event, refs, context, prop }) {\n        const scrollPosition = {\n          x: event.target.scrollLeft,\n          y: event.target.scrollTop\n        };\n        const scrollPositionRef = refs.get(\"scrollPosition\");\n        const offsetX = scrollPosition.x - scrollPositionRef.x;\n        const offsetY = scrollPosition.y - scrollPositionRef.y;\n        refs.set(\"scrollPosition\", scrollPosition);\n        context.set(\"atSides\", (prev) => {\n          const next = getScrollSides(event.target, prop(\"dir\"));\n          if (isEqual(prev, next)) return prev;\n          return next;\n        });\n        if (offsetY !== 0) {\n          context.set(\"scrollingY\", true);\n          refs.get(\"scrollYTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingY\", false);\n          });\n        }\n        if (offsetX !== 0) {\n          context.set(\"scrollingX\", true);\n          refs.get(\"scrollXTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingX\", false);\n          });\n        }\n      },\n      scrollToPointer({ event, scope, prop }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const thumbYRef = getThumbYEl(scope);\n        const scrollbarYRef = getScrollbarYEl(scope);\n        const thumbXRef = getThumbXEl(scope);\n        const scrollbarXRef = getScrollbarXEl(scope);\n        const client = event.point;\n        if (thumbYRef && scrollbarYRef && event.orientation === \"vertical\") {\n          const thumbYOffset = getScrollOffset(thumbYRef, \"margin\", \"y\");\n          const scrollbarYOffset = getScrollOffset(scrollbarYRef, \"padding\", \"y\");\n          const thumbHeight = thumbYRef.offsetHeight;\n          const trackRectY = scrollbarYRef.getBoundingClientRect();\n          const clickY = client.y - trackRectY.top - thumbHeight / 2 - scrollbarYOffset + thumbYOffset / 2;\n          const scrollableContentHeight = viewportEl.scrollHeight;\n          const viewportHeight = viewportEl.clientHeight;\n          const maxThumbOffsetY = scrollbarYRef.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = clickY / maxThumbOffsetY;\n          const newScrollTop = scrollRatioY * (scrollableContentHeight - viewportHeight);\n          viewportEl.scrollTop = newScrollTop;\n        }\n        if (thumbXRef && scrollbarXRef && event.orientation === \"horizontal\") {\n          const thumbXOffset = getScrollOffset(thumbXRef, \"margin\", \"x\");\n          const scrollbarXOffset = getScrollOffset(scrollbarXRef, \"padding\", \"x\");\n          const thumbWidth = thumbXRef.offsetWidth;\n          const trackRectX = scrollbarXRef.getBoundingClientRect();\n          const clickX = client.x - trackRectX.left - thumbWidth / 2 - scrollbarXOffset + thumbXOffset / 2;\n          const scrollableContentWidth = viewportEl.scrollWidth;\n          const viewportWidth = viewportEl.clientWidth;\n          const maxThumbOffsetX = scrollbarXRef.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = clickX / maxThumbOffsetX;\n          let newScrollLeft;\n          if (prop(\"dir\") === \"rtl\") {\n            newScrollLeft = (1 - scrollRatioX) * (scrollableContentWidth - viewportWidth);\n            if (viewportEl.scrollLeft <= 0) {\n              newScrollLeft = -newScrollLeft;\n            }\n          } else {\n            newScrollLeft = scrollRatioX * (scrollableContentWidth - viewportWidth);\n          }\n          viewportEl.scrollLeft = newScrollLeft;\n        }\n      },\n      startDragging({ event, refs, scope }) {\n        refs.set(\"startX\", event.point.x);\n        refs.set(\"startY\", event.point.y);\n        refs.set(\"orientation\", event.orientation);\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        refs.set(\"startScrollTop\", viewportEl.scrollTop);\n        refs.set(\"startScrollLeft\", viewportEl.scrollLeft);\n      },\n      setDraggingScroll({ event, refs, scope, context }) {\n        const startY = refs.get(\"startY\");\n        const startX = refs.get(\"startX\");\n        const startScrollTop = refs.get(\"startScrollTop\");\n        const startScrollLeft = refs.get(\"startScrollLeft\");\n        const client = event.point;\n        const deltaY = client.y - startY;\n        const deltaX = client.x - startX;\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const scrollableContentHeight = viewportEl.scrollHeight;\n        const viewportHeight = viewportEl.clientHeight;\n        const scrollableContentWidth = viewportEl.scrollWidth;\n        const viewportWidth = viewportEl.clientWidth;\n        const orientation = refs.get(\"orientation\");\n        const thumbYEl = getThumbYEl(scope);\n        const scrollbarYEl = getScrollbarYEl(scope);\n        if (thumbYEl && scrollbarYEl && orientation === \"vertical\") {\n          const scrollbarYOffset = getScrollOffset(scrollbarYEl, \"padding\", \"y\");\n          const thumbYOffset = getScrollOffset(thumbYEl, \"margin\", \"y\");\n          const thumbHeight = thumbYEl.offsetHeight;\n          const maxThumbOffsetY = scrollbarYEl.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = deltaY / maxThumbOffsetY;\n          viewportEl.scrollTop = startScrollTop + scrollRatioY * (scrollableContentHeight - viewportHeight);\n          context.set(\"scrollingY\", true);\n          refs.get(\"scrollYTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingY\", false);\n          });\n        }\n        const thumbXEl = getThumbXEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        if (thumbXEl && scrollbarXEl && orientation === \"horizontal\") {\n          const scrollbarXOffset = getScrollOffset(scrollbarXEl, \"padding\", \"x\");\n          const thumbXOffset = getScrollOffset(thumbXEl, \"margin\", \"x\");\n          const thumbWidth = thumbXEl.offsetWidth;\n          const maxThumbOffsetX = scrollbarXEl.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = deltaX / maxThumbOffsetX;\n          viewportEl.scrollLeft = startScrollLeft + scrollRatioX * (scrollableContentWidth - viewportWidth);\n          context.set(\"scrollingX\", true);\n          refs.get(\"scrollXTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingX\", false);\n          });\n        }\n      },\n      stopDragging({ refs }) {\n        refs.set(\"orientation\", null);\n      },\n      clearTimeouts({ refs }) {\n        refs.get(\"scrollYTimeout\").clear();\n        refs.get(\"scrollXTimeout\").clear();\n        refs.get(\"scrollEndTimeout\").clear();\n      }\n    },\n    effects: {\n      trackContentResize({ scope, send }) {\n        const contentEl = getContentEl(scope);\n        const rootEl = getRootEl(scope);\n        if (!contentEl || !rootEl) return;\n        const win = scope.getWin();\n        const obs = new win.ResizeObserver(() => {\n          setTimeout(() => {\n            send({ type: \"thumb.measure\" });\n          }, 1);\n        });\n        obs.observe(contentEl);\n        obs.observe(rootEl);\n        return () => {\n          obs.disconnect();\n        };\n      },\n      trackViewportVisibility({ scope, send }) {\n        const win = scope.getWin();\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const observer = new win.IntersectionObserver((entries) => {\n          entries.forEach((entry) => {\n            if (entry.intersectionRatio > 0) {\n              send({ type: \"thumb.measure\" });\n              observer.disconnect();\n            }\n          });\n        });\n        observer.observe(viewportEl);\n        return () => {\n          observer.disconnect();\n        };\n      },\n      trackWheelEvent({ scope }) {\n        const scrollbarYEl = getScrollbarYEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        if (!scrollbarYEl && !scrollbarXEl) return;\n        const onWheel = (event) => {\n          const viewportEl = getViewportEl(scope);\n          if (!viewportEl || event.ctrlKey) return;\n          const orientation = event.currentTarget.dataset.orientation;\n          if (orientation === \"vertical\") {\n            const canScrollY = viewportEl.scrollHeight > viewportEl.clientHeight;\n            const atTop = viewportEl.scrollTop === 0 && event.deltaY < 0;\n            const atBottom = viewportEl.scrollTop === viewportEl.scrollHeight - viewportEl.clientHeight && event.deltaY > 0;\n            const shouldScroll = canScrollY && event.deltaY !== 0 && !(atTop || atBottom);\n            if (!shouldScroll) return;\n            event.preventDefault();\n            viewportEl.scrollTop += event.deltaY;\n          } else if (orientation === \"horizontal\") {\n            const canScrollX = viewportEl.scrollWidth > viewportEl.clientWidth;\n            const atLeft = viewportEl.scrollLeft === 0 && event.deltaX < 0;\n            const atRight = viewportEl.scrollLeft === viewportEl.scrollWidth - viewportEl.clientWidth && event.deltaX > 0;\n            const shouldScroll = canScrollX && event.deltaX !== 0 && !(atLeft || atRight);\n            if (!shouldScroll) return;\n            event.preventDefault();\n            viewportEl.scrollLeft += event.deltaX;\n          }\n        };\n        return callAll(\n          scrollbarYEl && addDomEvent(scrollbarYEl, \"wheel\", onWheel, { passive: false }),\n          scrollbarXEl && addDomEvent(scrollbarXEl, \"wheel\", onWheel, { passive: false })\n        );\n      },\n      trackPointerMove({ scope, send, refs }) {\n        const doc = scope.getDoc();\n        const orientation = refs.get(\"orientation\");\n        return trackPointerMove(doc, {\n          onPointerMove({ point }) {\n            send({ type: \"thumb.pointermove\", orientation, point });\n          },\n          onPointerUp() {\n            send({ type: \"thumb.pointerup\", orientation });\n          }\n        });\n      }\n    }\n  }\n});\nvar props = createProps()([\"dir\", \"getRootNode\", \"ids\", \"id\"]);\nvar splitProps = createSplitProps(props);\n\nexport { anatomy, connect, machine, props, splitProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}